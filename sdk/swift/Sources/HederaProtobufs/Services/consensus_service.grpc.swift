//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: consensus_service.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf

///*
/// The Consensus Service provides the ability for Hedera Hashgraph to provide aBFT consensus as to
/// the order and validity of messages submitted to a *topic*, as well as a *consensus timestamp* for
/// those messages.
///
/// Automatic renewal can be configured via an autoRenewAccount.
/// Any time an autoRenewAccount is added to a topic, that createTopic/updateTopic transaction must
/// be signed by the autoRenewAccount.
///
/// The autoRenewPeriod on an account must currently be set a value in createTopic between
/// MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds). During
/// creation this sets the initial expirationTime of the topic (see more below).
///
/// If no adminKey is on a topic, there may not be an autoRenewAccount on the topic, deleteTopic is
/// not allowed, and the only change allowed via an updateTopic is to extend the expirationTime.
///
/// If an adminKey is on a topic, every updateTopic and deleteTopic transaction must be signed by the
/// adminKey, except for updateTopics which only extend the topic's expirationTime (no adminKey
/// authorization required).
///
/// If an updateTopic modifies the adminKey of a topic, the transaction signatures on the updateTopic
/// must fulfill both the pre-update and post-update adminKey signature requirements.
///
/// Mirrornet ConsensusService may be used to subscribe to changes on the topic, including changes to
/// the topic definition and the consensus ordering and timestamp of submitted messages.
///
/// Until autoRenew functionality is supported by HAPI, the topic will not expire, the
/// autoRenewAccount will not be charged, and the topic will not automatically be deleted.
///
/// Once autoRenew functionality is supported by HAPI:
///
/// 1. Once the expirationTime is encountered, if an autoRenewAccount is configured on the topic, the
/// account will be charged automatically at the expirationTime, to extend the expirationTime of the
/// topic up to the topic's autoRenewPeriod (or as much extension as the account's balance will
/// supply).
///
/// 2. If the topic expires and is not automatically renewed, the topic will enter the EXPIRED state.
/// All transactions on the topic will fail with TOPIC_EXPIRED, except an updateTopic() call that
/// modifies only the expirationTime.  getTopicInfo() will succeed. This state will be available for
/// a AUTORENEW_GRACE_PERIOD grace period (7 days).
///
/// 3. After the grace period, if the topic's expirationTime is not extended, the topic will be
/// automatically deleted and no transactions or queries on the topic will succeed after that point.
///
/// Usage: instantiate `Proto_ConsensusServiceClient`, then call methods of this protocol to make API calls.
public protocol Proto_ConsensusServiceClientProtocol: GRPCClient {
    var serviceName: String { get }
    var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? { get }

    func createTopic(
        _ request: Proto_Transaction,
        callOptions: CallOptions?
    ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

    func updateTopic(
        _ request: Proto_Transaction,
        callOptions: CallOptions?
    ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

    func deleteTopic(
        _ request: Proto_Transaction,
        callOptions: CallOptions?
    ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

    func getTopicInfo(
        _ request: Proto_Query,
        callOptions: CallOptions?
    ) -> UnaryCall<Proto_Query, Proto_Response>

    func submitMessage(
        _ request: Proto_Transaction,
        callOptions: CallOptions?
    ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>
}

extension Proto_ConsensusServiceClientProtocol {
    public var serviceName: String {
        return "proto.ConsensusService"
    }

    ///*
    /// Create a topic to be used for consensus.
    /// If an autoRenewAccount is specified, that account must also sign this transaction.
    /// If an adminKey is specified, the adminKey must sign the transaction.
    /// On success, the resulting TransactionReceipt contains the newly created TopicId.
    /// Request is [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
    ///
    /// - Parameters:
    ///   - request: Request to send to createTopic.
    ///   - callOptions: Call options.
    /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
    public func createTopic(
        _ request: Proto_Transaction,
        callOptions: CallOptions? = nil
    ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
        return self.makeUnaryCall(
            path: Proto_ConsensusServiceClientMetadata.Methods.createTopic.path,
            request: request,
            callOptions: callOptions ?? self.defaultCallOptions,
            interceptors: self.interceptors?.makecreateTopicInterceptors() ?? []
        )
    }

    ///*
    /// Update a topic.
    /// If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
    /// Otherwise transaction must be signed by the adminKey.
    /// If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
    /// If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
    /// Request is [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
    ///
    /// - Parameters:
    ///   - request: Request to send to updateTopic.
    ///   - callOptions: Call options.
    /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
    public func updateTopic(
        _ request: Proto_Transaction,
        callOptions: CallOptions? = nil
    ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
        return self.makeUnaryCall(
            path: Proto_ConsensusServiceClientMetadata.Methods.updateTopic.path,
            request: request,
            callOptions: callOptions ?? self.defaultCallOptions,
            interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? []
        )
    }

    ///*
    /// Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
    /// If an adminKey is set, this transaction must be signed by that key.
    /// If there is no adminKey, this transaction will fail UNAUTHORIZED.
    /// Request is [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
    ///
    /// - Parameters:
    ///   - request: Request to send to deleteTopic.
    ///   - callOptions: Call options.
    /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
    public func deleteTopic(
        _ request: Proto_Transaction,
        callOptions: CallOptions? = nil
    ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
        return self.makeUnaryCall(
            path: Proto_ConsensusServiceClientMetadata.Methods.deleteTopic.path,
            request: request,
            callOptions: callOptions ?? self.defaultCallOptions,
            interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? []
        )
    }

    ///*
    /// Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
    /// Deleted accounts will not be returned.
    /// Request is [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)
    /// Response is [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
    ///
    /// - Parameters:
    ///   - request: Request to send to getTopicInfo.
    ///   - callOptions: Call options.
    /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
    public func getTopicInfo(
        _ request: Proto_Query,
        callOptions: CallOptions? = nil
    ) -> UnaryCall<Proto_Query, Proto_Response> {
        return self.makeUnaryCall(
            path: Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo.path,
            request: request,
            callOptions: callOptions ?? self.defaultCallOptions,
            interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? []
        )
    }

    ///*
    /// Submit a message for consensus.
    /// Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
    /// mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
    /// The submitKey (if any) must sign this transaction.
    /// On success, the resulting TransactionReceipt contains the topic's updated topicSequenceNumber and
    /// topicRunningHash.
    /// Request is [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
    ///
    /// - Parameters:
    ///   - request: Request to send to submitMessage.
    ///   - callOptions: Call options.
    /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
    public func submitMessage(
        _ request: Proto_Transaction,
        callOptions: CallOptions? = nil
    ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
        return self.makeUnaryCall(
            path: Proto_ConsensusServiceClientMetadata.Methods.submitMessage.path,
            request: request,
            callOptions: callOptions ?? self.defaultCallOptions,
            interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? []
        )
    }
}

#if compiler(>=5.6)
    @available(*, deprecated)
    extension Proto_ConsensusServiceClient: @unchecked Sendable {}
#endif  // compiler(>=5.6)

@available(*, deprecated, renamed: "Proto_ConsensusServiceNIOClient")
public final class Proto_ConsensusServiceClient: Proto_ConsensusServiceClientProtocol {
    private let lock = Lock()
    private var _defaultCallOptions: CallOptions
    private var _interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol?
    public let channel: GRPCChannel
    public var defaultCallOptions: CallOptions {
        get { self.lock.withLock { return self._defaultCallOptions } }
        set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
    }
    public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? {
        get { self.lock.withLock { return self._interceptors } }
        set { self.lock.withLockVoid { self._interceptors = newValue } }
    }

    /// Creates a client for the proto.ConsensusService service.
    ///
    /// - Parameters:
    ///   - channel: `GRPCChannel` to the service host.
    ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
    ///   - interceptors: A factory providing interceptors for each RPC.
    public init(
        channel: GRPCChannel,
        defaultCallOptions: CallOptions = CallOptions(),
        interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? = nil
    ) {
        self.channel = channel
        self._defaultCallOptions = defaultCallOptions
        self._interceptors = interceptors
    }
}

public struct Proto_ConsensusServiceNIOClient: Proto_ConsensusServiceClientProtocol {
    public var channel: GRPCChannel
    public var defaultCallOptions: CallOptions
    public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol?

    /// Creates a client for the proto.ConsensusService service.
    ///
    /// - Parameters:
    ///   - channel: `GRPCChannel` to the service host.
    ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
    ///   - interceptors: A factory providing interceptors for each RPC.
    public init(
        channel: GRPCChannel,
        defaultCallOptions: CallOptions = CallOptions(),
        interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? = nil
    ) {
        self.channel = channel
        self.defaultCallOptions = defaultCallOptions
        self.interceptors = interceptors
    }
}

#if compiler(>=5.6)
    ///*
    /// The Consensus Service provides the ability for Hedera Hashgraph to provide aBFT consensus as to
    /// the order and validity of messages submitted to a *topic*, as well as a *consensus timestamp* for
    /// those messages.
    ///
    /// Automatic renewal can be configured via an autoRenewAccount.
    /// Any time an autoRenewAccount is added to a topic, that createTopic/updateTopic transaction must
    /// be signed by the autoRenewAccount.
    ///
    /// The autoRenewPeriod on an account must currently be set a value in createTopic between
    /// MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds). During
    /// creation this sets the initial expirationTime of the topic (see more below).
    ///
    /// If no adminKey is on a topic, there may not be an autoRenewAccount on the topic, deleteTopic is
    /// not allowed, and the only change allowed via an updateTopic is to extend the expirationTime.
    ///
    /// If an adminKey is on a topic, every updateTopic and deleteTopic transaction must be signed by the
    /// adminKey, except for updateTopics which only extend the topic's expirationTime (no adminKey
    /// authorization required).
    ///
    /// If an updateTopic modifies the adminKey of a topic, the transaction signatures on the updateTopic
    /// must fulfill both the pre-update and post-update adminKey signature requirements.
    ///
    /// Mirrornet ConsensusService may be used to subscribe to changes on the topic, including changes to
    /// the topic definition and the consensus ordering and timestamp of submitted messages.
    ///
    /// Until autoRenew functionality is supported by HAPI, the topic will not expire, the
    /// autoRenewAccount will not be charged, and the topic will not automatically be deleted.
    ///
    /// Once autoRenew functionality is supported by HAPI:
    ///
    /// 1. Once the expirationTime is encountered, if an autoRenewAccount is configured on the topic, the
    /// account will be charged automatically at the expirationTime, to extend the expirationTime of the
    /// topic up to the topic's autoRenewPeriod (or as much extension as the account's balance will
    /// supply).
    ///
    /// 2. If the topic expires and is not automatically renewed, the topic will enter the EXPIRED state.
    /// All transactions on the topic will fail with TOPIC_EXPIRED, except an updateTopic() call that
    /// modifies only the expirationTime.  getTopicInfo() will succeed. This state will be available for
    /// a AUTORENEW_GRACE_PERIOD grace period (7 days).
    ///
    /// 3. After the grace period, if the topic's expirationTime is not extended, the topic will be
    /// automatically deleted and no transactions or queries on the topic will succeed after that point.
    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public protocol Proto_ConsensusServiceAsyncClientProtocol: GRPCClient {
        static var serviceDescriptor: GRPCServiceDescriptor { get }
        var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? { get }

        func makeCreateTopicCall(
            _ request: Proto_Transaction,
            callOptions: CallOptions?
        ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

        func makeUpdateTopicCall(
            _ request: Proto_Transaction,
            callOptions: CallOptions?
        ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

        func makeDeleteTopicCall(
            _ request: Proto_Transaction,
            callOptions: CallOptions?
        ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

        func makeGetTopicInfoCall(
            _ request: Proto_Query,
            callOptions: CallOptions?
        ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response>

        func makeSubmitMessageCall(
            _ request: Proto_Transaction,
            callOptions: CallOptions?
        ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    extension Proto_ConsensusServiceAsyncClientProtocol {
        public static var serviceDescriptor: GRPCServiceDescriptor {
            return Proto_ConsensusServiceClientMetadata.serviceDescriptor
        }

        public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? {
            return nil
        }

        public func makeCreateTopicCall(
            _ request: Proto_Transaction,
            callOptions: CallOptions? = nil
        ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
            return self.makeAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.createTopic.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makecreateTopicInterceptors() ?? []
            )
        }

        public func makeUpdateTopicCall(
            _ request: Proto_Transaction,
            callOptions: CallOptions? = nil
        ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
            return self.makeAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.updateTopic.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? []
            )
        }

        public func makeDeleteTopicCall(
            _ request: Proto_Transaction,
            callOptions: CallOptions? = nil
        ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
            return self.makeAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.deleteTopic.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? []
            )
        }

        public func makeGetTopicInfoCall(
            _ request: Proto_Query,
            callOptions: CallOptions? = nil
        ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response> {
            return self.makeAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? []
            )
        }

        public func makeSubmitMessageCall(
            _ request: Proto_Transaction,
            callOptions: CallOptions? = nil
        ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
            return self.makeAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.submitMessage.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? []
            )
        }
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    extension Proto_ConsensusServiceAsyncClientProtocol {
        public func createTopic(
            _ request: Proto_Transaction,
            callOptions: CallOptions? = nil
        ) async throws -> Proto_TransactionResponse {
            return try await self.performAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.createTopic.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makecreateTopicInterceptors() ?? []
            )
        }

        public func updateTopic(
            _ request: Proto_Transaction,
            callOptions: CallOptions? = nil
        ) async throws -> Proto_TransactionResponse {
            return try await self.performAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.updateTopic.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? []
            )
        }

        public func deleteTopic(
            _ request: Proto_Transaction,
            callOptions: CallOptions? = nil
        ) async throws -> Proto_TransactionResponse {
            return try await self.performAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.deleteTopic.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? []
            )
        }

        public func getTopicInfo(
            _ request: Proto_Query,
            callOptions: CallOptions? = nil
        ) async throws -> Proto_Response {
            return try await self.performAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? []
            )
        }

        public func submitMessage(
            _ request: Proto_Transaction,
            callOptions: CallOptions? = nil
        ) async throws -> Proto_TransactionResponse {
            return try await self.performAsyncUnaryCall(
                path: Proto_ConsensusServiceClientMetadata.Methods.submitMessage.path,
                request: request,
                callOptions: callOptions ?? self.defaultCallOptions,
                interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? []
            )
        }
    }

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public struct Proto_ConsensusServiceAsyncClient: Proto_ConsensusServiceAsyncClientProtocol {
        public var channel: GRPCChannel
        public var defaultCallOptions: CallOptions
        public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol?

        public init(
            channel: GRPCChannel,
            defaultCallOptions: CallOptions = CallOptions(),
            interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? = nil
        ) {
            self.channel = channel
            self.defaultCallOptions = defaultCallOptions
            self.interceptors = interceptors
        }
    }

#endif  // compiler(>=5.6)

public protocol Proto_ConsensusServiceClientInterceptorFactoryProtocol: GRPCSendable {

    /// - Returns: Interceptors to use when invoking 'createTopic'.
    func makecreateTopicInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

    /// - Returns: Interceptors to use when invoking 'updateTopic'.
    func makeupdateTopicInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

    /// - Returns: Interceptors to use when invoking 'deleteTopic'.
    func makedeleteTopicInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

    /// - Returns: Interceptors to use when invoking 'getTopicInfo'.
    func makegetTopicInfoInterceptors() -> [ClientInterceptor<Proto_Query, Proto_Response>]

    /// - Returns: Interceptors to use when invoking 'submitMessage'.
    func makesubmitMessageInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]
}

public enum Proto_ConsensusServiceClientMetadata {
    public static let serviceDescriptor = GRPCServiceDescriptor(
        name: "ConsensusService",
        fullName: "proto.ConsensusService",
        methods: [
            Proto_ConsensusServiceClientMetadata.Methods.createTopic,
            Proto_ConsensusServiceClientMetadata.Methods.updateTopic,
            Proto_ConsensusServiceClientMetadata.Methods.deleteTopic,
            Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo,
            Proto_ConsensusServiceClientMetadata.Methods.submitMessage,
        ]
    )

    public enum Methods {
        public static let createTopic = GRPCMethodDescriptor(
            name: "createTopic",
            path: "/proto.ConsensusService/createTopic",
            type: GRPCCallType.unary
        )

        public static let updateTopic = GRPCMethodDescriptor(
            name: "updateTopic",
            path: "/proto.ConsensusService/updateTopic",
            type: GRPCCallType.unary
        )

        public static let deleteTopic = GRPCMethodDescriptor(
            name: "deleteTopic",
            path: "/proto.ConsensusService/deleteTopic",
            type: GRPCCallType.unary
        )

        public static let getTopicInfo = GRPCMethodDescriptor(
            name: "getTopicInfo",
            path: "/proto.ConsensusService/getTopicInfo",
            type: GRPCCallType.unary
        )

        public static let submitMessage = GRPCMethodDescriptor(
            name: "submitMessage",
            path: "/proto.ConsensusService/submitMessage",
            type: GRPCCallType.unary
        )
    }
}
