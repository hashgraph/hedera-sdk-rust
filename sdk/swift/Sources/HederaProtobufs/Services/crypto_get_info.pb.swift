// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: crypto_get_info.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Get all the information about an account, including the balance. This does not get the list of
/// account records.
public struct Proto_CryptoGetInfoQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Standard info sent from client to node, including the signed payment, and what kind of
  /// response is requested (cost, state proof, both, or neither).
  public var header: Proto_QueryHeader {
    get {return _header ?? Proto_QueryHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  ///*
  /// The account ID for which information is requested
  public var accountID: Proto_AccountID {
    get {return _accountID ?? Proto_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Proto_QueryHeader? = nil
  fileprivate var _accountID: Proto_AccountID? = nil
}

///*
/// Response when the client sends the node CryptoGetInfoQuery
public struct Proto_CryptoGetInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Standard response from node to client, including the requested fields: cost, or state proof,
  /// or both, or neither
  public var header: Proto_ResponseHeader {
    get {return _header ?? Proto_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  ///*
  /// Info about the account (a state proof can be generated for this)
  public var accountInfo: Proto_CryptoGetInfoResponse.AccountInfo {
    get {return _accountInfo ?? Proto_CryptoGetInfoResponse.AccountInfo()}
    set {_accountInfo = newValue}
  }
  /// Returns true if `accountInfo` has been explicitly set.
  public var hasAccountInfo: Bool {return self._accountInfo != nil}
  /// Clears the value of `accountInfo`. Subsequent reads from it will return its default value.
  public mutating func clearAccountInfo() {self._accountInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct AccountInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///*
    /// The account ID for which this information applies
    public var accountID: Proto_AccountID {
      get {return _storage._accountID ?? Proto_AccountID()}
      set {_uniqueStorage()._accountID = newValue}
    }
    /// Returns true if `accountID` has been explicitly set.
    public var hasAccountID: Bool {return _storage._accountID != nil}
    /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
    public mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

    ///*
    /// The Contract Account ID comprising of both the contract instance and the cryptocurrency
    /// account owned by the contract instance, in the format used by Solidity
    public var contractAccountID: String {
      get {return _storage._contractAccountID}
      set {_uniqueStorage()._contractAccountID = newValue}
    }

    ///*
    /// If true, then this account has been deleted, it will disappear when it expires, and all
    /// transactions for it will fail except the transaction to extend its expiration date
    public var deleted: Bool {
      get {return _storage._deleted}
      set {_uniqueStorage()._deleted = newValue}
    }

    ///*
    /// [Deprecated] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
    /// or is an invalid account, or is an account that isn't a node, then this account is
    /// automatically proxy staked to a node chosen by the network, but without earning payments.
    /// If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
    /// running a node, then it will behave as if proxyAccountID was null.
    public var proxyAccountID: Proto_AccountID {
      get {return _storage._proxyAccountID ?? Proto_AccountID()}
      set {_uniqueStorage()._proxyAccountID = newValue}
    }
    /// Returns true if `proxyAccountID` has been explicitly set.
    public var hasProxyAccountID: Bool {return _storage._proxyAccountID != nil}
    /// Clears the value of `proxyAccountID`. Subsequent reads from it will return its default value.
    public mutating func clearProxyAccountID() {_uniqueStorage()._proxyAccountID = nil}

    ///*
    /// The total number of tinybars proxy staked to this account
    public var proxyReceived: Int64 {
      get {return _storage._proxyReceived}
      set {_uniqueStorage()._proxyReceived = newValue}
    }

    ///*
    /// The key for the account, which must sign in order to transfer out, or to modify the
    /// account in any way other than extending its expiration date.
    public var key: Proto_Key {
      get {return _storage._key ?? Proto_Key()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {_uniqueStorage()._key = nil}

    ///*
    /// The current balance of account in tinybars
    public var balance: UInt64 {
      get {return _storage._balance}
      set {_uniqueStorage()._balance = newValue}
    }

    ///*
    /// [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
    /// transaction that decreases the balance of this account by more than the threshold
    public var generateSendRecordThreshold: UInt64 {
      get {return _storage._generateSendRecordThreshold}
      set {_uniqueStorage()._generateSendRecordThreshold = newValue}
    }

    ///*
    /// [Deprecated]. The threshold amount, in tinybars, at which a record is created of any
    /// transaction that increases the balance of this account by more than the threshold
    public var generateReceiveRecordThreshold: UInt64 {
      get {return _storage._generateReceiveRecordThreshold}
      set {_uniqueStorage()._generateReceiveRecordThreshold = newValue}
    }

    ///*
    /// If true, no transaction can transfer to this account unless signed by this account's key
    public var receiverSigRequired: Bool {
      get {return _storage._receiverSigRequired}
      set {_uniqueStorage()._receiverSigRequired = newValue}
    }

    ///*
    /// The TimeStamp time at which this account is set to expire
    public var expirationTime: Proto_Timestamp {
      get {return _storage._expirationTime ?? Proto_Timestamp()}
      set {_uniqueStorage()._expirationTime = newValue}
    }
    /// Returns true if `expirationTime` has been explicitly set.
    public var hasExpirationTime: Bool {return _storage._expirationTime != nil}
    /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
    public mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

    ///*
    /// The duration for expiration time will extend every this many seconds. If there are
    /// insufficient funds, then it extends as long as possible. If it is empty when it expires,
    /// then it is deleted.
    public var autoRenewPeriod: Proto_Duration {
      get {return _storage._autoRenewPeriod ?? Proto_Duration()}
      set {_uniqueStorage()._autoRenewPeriod = newValue}
    }
    /// Returns true if `autoRenewPeriod` has been explicitly set.
    public var hasAutoRenewPeriod: Bool {return _storage._autoRenewPeriod != nil}
    /// Clears the value of `autoRenewPeriod`. Subsequent reads from it will return its default value.
    public mutating func clearAutoRenewPeriod() {_uniqueStorage()._autoRenewPeriod = nil}

    ///*
    /// All of the livehashes attached to the account (each of which is a hash along with the
    /// keys that authorized it and can delete it)
    public var liveHashes: [Proto_LiveHash] {
      get {return _storage._liveHashes}
      set {_uniqueStorage()._liveHashes = newValue}
    }

    ///*
    /// [DEPRECATED] The metadata of the tokens associated to the account. This field was
    /// deprecated by <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>, which allowed
    /// an account to be associated to an unlimited number of tokens. This scale makes it more
    /// efficient for users to consult mirror nodes to review their token associations.
    public var tokenRelationships: [Proto_TokenRelationship] {
      get {return _storage._tokenRelationships}
      set {_uniqueStorage()._tokenRelationships = newValue}
    }

    ///*
    /// The memo associated with the account
    public var memo: String {
      get {return _storage._memo}
      set {_uniqueStorage()._memo = newValue}
    }

    ///*
    /// The number of NFTs owned by this account
    public var ownedNfts: Int64 {
      get {return _storage._ownedNfts}
      set {_uniqueStorage()._ownedNfts = newValue}
    }

    ///*
    /// The maximum number of tokens that an Account can be implicitly associated with.
    public var maxAutomaticTokenAssociations: Int32 {
      get {return _storage._maxAutomaticTokenAssociations}
      set {_uniqueStorage()._maxAutomaticTokenAssociations = newValue}
    }

    ///*
    /// The alias of this account
    public var alias: Data {
      get {return _storage._alias}
      set {_uniqueStorage()._alias = newValue}
    }

    ///*
    /// The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
    public var ledgerID: Data {
      get {return _storage._ledgerID}
      set {_uniqueStorage()._ledgerID = newValue}
    }

    ///*
    /// The ethereum transaction nonce associated with this account.
    public var ethereumNonce: Int64 {
      get {return _storage._ethereumNonce}
      set {_uniqueStorage()._ethereumNonce = newValue}
    }

    ///*
    /// Staking metadata for this account.
    public var stakingInfo: Proto_StakingInfo {
      get {return _storage._stakingInfo ?? Proto_StakingInfo()}
      set {_uniqueStorage()._stakingInfo = newValue}
    }
    /// Returns true if `stakingInfo` has been explicitly set.
    public var hasStakingInfo: Bool {return _storage._stakingInfo != nil}
    /// Clears the value of `stakingInfo`. Subsequent reads from it will return its default value.
    public mutating func clearStakingInfo() {_uniqueStorage()._stakingInfo = nil}

    ///*
    /// If present, the account that will be charged for auto-renewal of this account. If not set,
    /// or set to an account with zero hbar balance, the account's own hbar balance will be used to
    /// cover auto-renewal fees.
    public var autoRenewAccount: Proto_AccountID {
      get {return _storage._autoRenewAccount ?? Proto_AccountID()}
      set {_uniqueStorage()._autoRenewAccount = newValue}
    }
    /// Returns true if `autoRenewAccount` has been explicitly set.
    public var hasAutoRenewAccount: Bool {return _storage._autoRenewAccount != nil}
    /// Clears the value of `autoRenewAccount`. Subsequent reads from it will return its default value.
    public mutating func clearAutoRenewAccount() {_uniqueStorage()._autoRenewAccount = nil}

    ///*
    /// List of virtual addresses each of which is an EVM address that maps to an ECDSA key pair a user must prove ownership of.
    public var virtualAddresses: [Proto_VirtualAddress] {
      get {return _storage._virtualAddresses}
      set {_uniqueStorage()._virtualAddresses = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _header: Proto_ResponseHeader? = nil
  fileprivate var _accountInfo: Proto_CryptoGetInfoResponse.AccountInfo? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_CryptoGetInfoQuery: @unchecked Sendable {}
extension Proto_CryptoGetInfoResponse: @unchecked Sendable {}
extension Proto_CryptoGetInfoResponse.AccountInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_CryptoGetInfoQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoGetInfoQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "accountID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CryptoGetInfoQuery, rhs: Proto_CryptoGetInfoQuery) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CryptoGetInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoGetInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "accountInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CryptoGetInfoResponse, rhs: Proto_CryptoGetInfoResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._accountInfo != rhs._accountInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CryptoGetInfoResponse.AccountInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Proto_CryptoGetInfoResponse.protoMessageName + ".AccountInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountID"),
    2: .same(proto: "contractAccountID"),
    3: .same(proto: "deleted"),
    4: .same(proto: "proxyAccountID"),
    6: .same(proto: "proxyReceived"),
    7: .same(proto: "key"),
    8: .same(proto: "balance"),
    9: .same(proto: "generateSendRecordThreshold"),
    10: .same(proto: "generateReceiveRecordThreshold"),
    11: .same(proto: "receiverSigRequired"),
    12: .same(proto: "expirationTime"),
    13: .same(proto: "autoRenewPeriod"),
    14: .same(proto: "liveHashes"),
    15: .same(proto: "tokenRelationships"),
    16: .same(proto: "memo"),
    17: .same(proto: "ownedNfts"),
    18: .standard(proto: "max_automatic_token_associations"),
    19: .same(proto: "alias"),
    20: .standard(proto: "ledger_id"),
    21: .standard(proto: "ethereum_nonce"),
    22: .standard(proto: "staking_info"),
    23: .standard(proto: "auto_renew_account"),
    24: .standard(proto: "virtual_addresses"),
  ]

  fileprivate class _StorageClass {
    var _accountID: Proto_AccountID? = nil
    var _contractAccountID: String = String()
    var _deleted: Bool = false
    var _proxyAccountID: Proto_AccountID? = nil
    var _proxyReceived: Int64 = 0
    var _key: Proto_Key? = nil
    var _balance: UInt64 = 0
    var _generateSendRecordThreshold: UInt64 = 0
    var _generateReceiveRecordThreshold: UInt64 = 0
    var _receiverSigRequired: Bool = false
    var _expirationTime: Proto_Timestamp? = nil
    var _autoRenewPeriod: Proto_Duration? = nil
    var _liveHashes: [Proto_LiveHash] = []
    var _tokenRelationships: [Proto_TokenRelationship] = []
    var _memo: String = String()
    var _ownedNfts: Int64 = 0
    var _maxAutomaticTokenAssociations: Int32 = 0
    var _alias: Data = Data()
    var _ledgerID: Data = Data()
    var _ethereumNonce: Int64 = 0
    var _stakingInfo: Proto_StakingInfo? = nil
    var _autoRenewAccount: Proto_AccountID? = nil
    var _virtualAddresses: [Proto_VirtualAddress] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _contractAccountID = source._contractAccountID
      _deleted = source._deleted
      _proxyAccountID = source._proxyAccountID
      _proxyReceived = source._proxyReceived
      _key = source._key
      _balance = source._balance
      _generateSendRecordThreshold = source._generateSendRecordThreshold
      _generateReceiveRecordThreshold = source._generateReceiveRecordThreshold
      _receiverSigRequired = source._receiverSigRequired
      _expirationTime = source._expirationTime
      _autoRenewPeriod = source._autoRenewPeriod
      _liveHashes = source._liveHashes
      _tokenRelationships = source._tokenRelationships
      _memo = source._memo
      _ownedNfts = source._ownedNfts
      _maxAutomaticTokenAssociations = source._maxAutomaticTokenAssociations
      _alias = source._alias
      _ledgerID = source._ledgerID
      _ethereumNonce = source._ethereumNonce
      _stakingInfo = source._stakingInfo
      _autoRenewAccount = source._autoRenewAccount
      _virtualAddresses = source._virtualAddresses
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._accountID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._contractAccountID) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._deleted) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._proxyAccountID) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._proxyReceived) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._balance) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._generateSendRecordThreshold) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._generateReceiveRecordThreshold) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._receiverSigRequired) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._expirationTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewPeriod) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._liveHashes) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokenRelationships) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._ownedNfts) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._maxAutomaticTokenAssociations) }()
        case 19: try { try decoder.decodeSingularBytesField(value: &_storage._alias) }()
        case 20: try { try decoder.decodeSingularBytesField(value: &_storage._ledgerID) }()
        case 21: try { try decoder.decodeSingularInt64Field(value: &_storage._ethereumNonce) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._stakingInfo) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewAccount) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._virtualAddresses) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._contractAccountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contractAccountID, fieldNumber: 2)
      }
      if _storage._deleted != false {
        try visitor.visitSingularBoolField(value: _storage._deleted, fieldNumber: 3)
      }
      try { if let v = _storage._proxyAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._proxyReceived != 0 {
        try visitor.visitSingularInt64Field(value: _storage._proxyReceived, fieldNumber: 6)
      }
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._balance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._balance, fieldNumber: 8)
      }
      if _storage._generateSendRecordThreshold != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._generateSendRecordThreshold, fieldNumber: 9)
      }
      if _storage._generateReceiveRecordThreshold != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._generateReceiveRecordThreshold, fieldNumber: 10)
      }
      if _storage._receiverSigRequired != false {
        try visitor.visitSingularBoolField(value: _storage._receiverSigRequired, fieldNumber: 11)
      }
      try { if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._autoRenewPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._liveHashes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._liveHashes, fieldNumber: 14)
      }
      if !_storage._tokenRelationships.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokenRelationships, fieldNumber: 15)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 16)
      }
      if _storage._ownedNfts != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ownedNfts, fieldNumber: 17)
      }
      if _storage._maxAutomaticTokenAssociations != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxAutomaticTokenAssociations, fieldNumber: 18)
      }
      if !_storage._alias.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._alias, fieldNumber: 19)
      }
      if !_storage._ledgerID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._ledgerID, fieldNumber: 20)
      }
      if _storage._ethereumNonce != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ethereumNonce, fieldNumber: 21)
      }
      try { if let v = _storage._stakingInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._autoRenewAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if !_storage._virtualAddresses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._virtualAddresses, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CryptoGetInfoResponse.AccountInfo, rhs: Proto_CryptoGetInfoResponse.AccountInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._contractAccountID != rhs_storage._contractAccountID {return false}
        if _storage._deleted != rhs_storage._deleted {return false}
        if _storage._proxyAccountID != rhs_storage._proxyAccountID {return false}
        if _storage._proxyReceived != rhs_storage._proxyReceived {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._generateSendRecordThreshold != rhs_storage._generateSendRecordThreshold {return false}
        if _storage._generateReceiveRecordThreshold != rhs_storage._generateReceiveRecordThreshold {return false}
        if _storage._receiverSigRequired != rhs_storage._receiverSigRequired {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._autoRenewPeriod != rhs_storage._autoRenewPeriod {return false}
        if _storage._liveHashes != rhs_storage._liveHashes {return false}
        if _storage._tokenRelationships != rhs_storage._tokenRelationships {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._ownedNfts != rhs_storage._ownedNfts {return false}
        if _storage._maxAutomaticTokenAssociations != rhs_storage._maxAutomaticTokenAssociations {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._ledgerID != rhs_storage._ledgerID {return false}
        if _storage._ethereumNonce != rhs_storage._ethereumNonce {return false}
        if _storage._stakingInfo != rhs_storage._stakingInfo {return false}
        if _storage._autoRenewAccount != rhs_storage._autoRenewAccount {return false}
        if _storage._virtualAddresses != rhs_storage._virtualAddresses {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
