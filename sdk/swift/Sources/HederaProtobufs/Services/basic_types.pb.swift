// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: basic_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Possible Token Types (IWA Compatibility).
/// Apart from fungible and non-fungible, Tokens can have either a common or unique representation.
/// This distinction might seem subtle, but it is important when considering how tokens can be traced
/// and if they can have isolated and unique properties.
public enum Proto_TokenType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///*
  /// Interchangeable value with one another, where any quantity of them has the same value as
  /// another equal quantity if they are in the same class.  Share a single set of properties, not
  /// distinct from one another. Simply represented as a balance or quantity to a given Hedera
  /// account.
  case fungibleCommon // = 0

  ///*
  /// Unique, not interchangeable with other tokens of the same type as they typically have
  /// different values.  Individually traced and can carry unique properties (e.g. serial number).
  case nonFungibleUnique // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .fungibleCommon
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fungibleCommon
    case 1: self = .nonFungibleUnique
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .fungibleCommon: return 0
    case .nonFungibleUnique: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_TokenType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_TokenType] = [
    .fungibleCommon,
    .nonFungibleUnique,
  ]
}

#endif  // swift(>=4.2)

///*
/// Allows a set of resource prices to be scoped to a certain type of a HAPI operation.
///
/// For example, the resource prices for a TokenMint operation are different between minting fungible
/// and non-fungible tokens. This enum allows us to "mark" a set of prices as applying to one or the
/// other.
///
/// Similarly, the resource prices for a basic TokenCreate without a custom fee schedule yield a
/// total price of $1. The resource prices for a TokenCreate with a custom fee schedule are different
/// and yield a total base price of $2.
public enum Proto_SubType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///*
  /// The resource prices have no special scope
  case `default` // = 0

  ///*
  /// The resource prices are scoped to an operation on a fungible common token
  case tokenFungibleCommon // = 1

  ///*
  /// The resource prices are scoped to an operation on a non-fungible unique token
  case tokenNonFungibleUnique // = 2

  ///*
  /// The resource prices are scoped to an operation on a fungible common
  /// token with a custom fee schedule
  case tokenFungibleCommonWithCustomFees // = 3

  ///*
  /// The resource prices are scoped to an operation on a non-fungible unique
  /// token with a custom fee schedule
  case tokenNonFungibleUniqueWithCustomFees // = 4

  ///*
  /// The resource prices are scoped to a ScheduleCreate containing a ContractCall.
  case scheduleCreateContractCall // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .tokenFungibleCommon
    case 2: self = .tokenNonFungibleUnique
    case 3: self = .tokenFungibleCommonWithCustomFees
    case 4: self = .tokenNonFungibleUniqueWithCustomFees
    case 5: self = .scheduleCreateContractCall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .tokenFungibleCommon: return 1
    case .tokenNonFungibleUnique: return 2
    case .tokenFungibleCommonWithCustomFees: return 3
    case .tokenNonFungibleUniqueWithCustomFees: return 4
    case .scheduleCreateContractCall: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_SubType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_SubType] = [
    .default,
    .tokenFungibleCommon,
    .tokenNonFungibleUnique,
    .tokenFungibleCommonWithCustomFees,
    .tokenNonFungibleUniqueWithCustomFees,
    .scheduleCreateContractCall,
  ]
}

#endif  // swift(>=4.2)

///*
/// Possible Token Supply Types (IWA Compatibility).
/// Indicates how many tokens can have during its lifetime.
public enum Proto_TokenSupplyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///*
  /// Indicates that tokens of that type have an upper bound of Long.MAX_VALUE.
  case infinite // = 0

  ///*
  /// Indicates that tokens of that type have an upper bound of maxSupply,
  /// provided on token creation.
  case finite // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .infinite
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .infinite
    case 1: self = .finite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .infinite: return 0
    case .finite: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_TokenSupplyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_TokenSupplyType] = [
    .infinite,
    .finite,
  ]
}

#endif  // swift(>=4.2)

///*
/// Possible Freeze statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in
/// TokenRelationship
public enum Proto_TokenFreezeStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///*
  /// UNDOCUMENTED
  case freezeNotApplicable // = 0

  ///*
  /// UNDOCUMENTED
  case frozen // = 1

  ///*
  /// UNDOCUMENTED
  case unfrozen // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .freezeNotApplicable
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .freezeNotApplicable
    case 1: self = .frozen
    case 2: self = .unfrozen
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .freezeNotApplicable: return 0
    case .frozen: return 1
    case .unfrozen: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_TokenFreezeStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_TokenFreezeStatus] = [
    .freezeNotApplicable,
    .frozen,
    .unfrozen,
  ]
}

#endif  // swift(>=4.2)

///*
/// Possible KYC statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship
public enum Proto_TokenKycStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///*
  /// UNDOCUMENTED
  case kycNotApplicable // = 0

  ///*
  /// UNDOCUMENTED
  case granted // = 1

  ///*
  /// UNDOCUMENTED
  case revoked // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .kycNotApplicable
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .kycNotApplicable
    case 1: self = .granted
    case 2: self = .revoked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .kycNotApplicable: return 0
    case .granted: return 1
    case .revoked: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_TokenKycStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_TokenKycStatus] = [
    .kycNotApplicable,
    .granted,
    .revoked,
  ]
}

#endif  // swift(>=4.2)

///*
/// Possible Pause statuses returned on TokenGetInfoQuery
public enum Proto_TokenPauseStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///*
  /// Indicates that a Token has no pauseKey
  case pauseNotApplicable // = 0

  ///*
  /// Indicates that a Token is Paused
  case paused // = 1

  ///*
  /// Indicates that a Token is Unpaused.
  case unpaused // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .pauseNotApplicable
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pauseNotApplicable
    case 1: self = .paused
    case 2: self = .unpaused
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .pauseNotApplicable: return 0
    case .paused: return 1
    case .unpaused: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_TokenPauseStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_TokenPauseStatus] = [
    .pauseNotApplicable,
    .paused,
    .unpaused,
  ]
}

#endif  // swift(>=4.2)

///*
/// The transactions and queries supported by Hedera Hashgraph.
public enum Proto_HederaFunctionality: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///*
  /// UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and
  /// not parsed (0 is ignored by parser)
  case none // = 0

  ///*
  /// crypto transfer
  case cryptoTransfer // = 1

  ///*
  /// crypto update account
  case cryptoUpdate // = 2

  ///*
  /// crypto delete account
  case cryptoDelete // = 3

  ///*
  /// Add a livehash to a crypto account
  case cryptoAddLiveHash // = 4

  ///*
  /// Delete a livehash from a crypto account
  case cryptoDeleteLiveHash // = 5

  ///*
  /// Smart Contract Call
  case contractCall // = 6

  ///*
  /// Smart Contract Create Contract
  case contractCreate // = 7

  ///*
  /// Smart Contract update contract
  case contractUpdate // = 8

  ///*
  /// File Operation create file
  case fileCreate // = 9

  ///*
  /// File Operation append file
  case fileAppend // = 10

  ///*
  /// File Operation update file
  case fileUpdate // = 11

  ///*
  /// File Operation delete file
  case fileDelete // = 12

  ///*
  /// crypto get account balance
  case cryptoGetAccountBalance // = 13

  ///*
  /// crypto get account record
  case cryptoGetAccountRecords // = 14

  ///*
  /// Crypto get info
  case cryptoGetInfo // = 15

  ///*
  /// Smart Contract Call
  case contractCallLocal // = 16

  ///*
  /// Smart Contract get info
  case contractGetInfo // = 17

  ///*
  /// Smart Contract, get the runtime code
  case contractGetBytecode // = 18

  ///*
  /// Smart Contract, get by solidity ID
  case getBySolidityID // = 19

  ///*
  /// Smart Contract, get by key
  case getByKey // = 20

  ///*
  /// Get a live hash from a crypto account
  case cryptoGetLiveHash // = 21

  ///*
  /// Crypto, get the stakers for the node
  case cryptoGetStakers // = 22

  ///*
  /// File Operations get file contents
  case fileGetContents // = 23

  ///*
  /// File Operations get the info of the file
  case fileGetInfo // = 24

  ///*
  /// Crypto get the transaction records
  case transactionGetRecord // = 25

  ///*
  /// Contract get the transaction records
  case contractGetRecords // = 26

  ///*
  /// crypto create account
  case cryptoCreate // = 27

  ///*
  /// system delete file
  case systemDelete // = 28

  ///*
  /// system undelete file
  case systemUndelete // = 29

  ///*
  /// delete contract
  case contractDelete // = 30

  ///*
  /// freeze
  case freeze // = 31

  ///*
  /// Create Tx Record
  case createTransactionRecord // = 32

  ///*
  /// Crypto Auto Renew
  case cryptoAccountAutoRenew // = 33

  ///*
  /// Contract Auto Renew
  case contractAutoRenew // = 34

  ///*
  /// Get Version
  case getVersionInfo // = 35

  ///*
  /// Transaction Get Receipt
  case transactionGetReceipt // = 36

  ///*
  /// Create Topic
  case consensusCreateTopic // = 50

  ///*
  /// Update Topic
  case consensusUpdateTopic // = 51

  ///*
  /// Delete Topic
  case consensusDeleteTopic // = 52

  ///*
  /// Get Topic information
  case consensusGetTopicInfo // = 53

  ///*
  /// Submit message to topic
  case consensusSubmitMessage // = 54
  case uncheckedSubmit // = 55

  ///*
  /// Create Token
  case tokenCreate // = 56

  ///*
  /// Get Token information
  case tokenGetInfo // = 58

  ///*
  /// Freeze Account
  case tokenFreezeAccount // = 59

  ///*
  /// Unfreeze Account
  case tokenUnfreezeAccount // = 60

  ///*
  /// Grant KYC to Account
  case tokenGrantKycToAccount // = 61

  ///*
  /// Revoke KYC from Account
  case tokenRevokeKycFromAccount // = 62

  ///*
  /// Delete Token
  case tokenDelete // = 63

  ///*
  /// Update Token
  case tokenUpdate // = 64

  ///*
  /// Mint tokens to treasury
  case tokenMint // = 65

  ///*
  /// Burn tokens from treasury
  case tokenBurn // = 66

  ///*
  /// Wipe token amount from Account holder
  case tokenAccountWipe // = 67

  ///*
  /// Associate tokens to an account
  case tokenAssociateToAccount // = 68

  ///*
  /// Dissociate tokens from an account
  case tokenDissociateFromAccount // = 69

  ///*
  /// Create Scheduled Transaction
  case scheduleCreate // = 70

  ///*
  /// Delete Scheduled Transaction
  case scheduleDelete // = 71

  ///*
  /// Sign Scheduled Transaction
  case scheduleSign // = 72

  ///*
  /// Get Scheduled Transaction Information
  case scheduleGetInfo // = 73

  ///*
  /// Get Token Account Nft Information
  case tokenGetAccountNftInfos // = 74

  ///*
  /// Get Token Nft Information
  case tokenGetNftInfo // = 75

  ///*
  /// Get Token Nft List Information
  case tokenGetNftInfos // = 76

  ///*
  /// Update a token's custom fee schedule, if permissible
  case tokenFeeScheduleUpdate // = 77

  ///*
  /// Get execution time(s) by TransactionID, if available
  case networkGetExecutionTime // = 78

  ///*
  /// Pause the Token
  case tokenPause // = 79

  ///*
  /// Unpause the Token
  case tokenUnpause // = 80

  ///*
  /// Approve allowance for a spender relative to the owner account
  case cryptoApproveAllowance // = 81

  ///*
  /// Deletes granted allowances on owner account
  case cryptoDeleteAllowance // = 82

  ///*
  /// Gets all the information about an account, including balance and allowances. This does not get the list of
  /// account records.
  case getAccountDetails // = 83

  ///*
  /// Ethereum Transaction
  case ethereumTransaction // = 84

  ///*
  /// Updates the staking info at the end of staking period to indicate new staking period has started.
  case nodeStakeUpdate // = 85

  ///*
  /// Generates a pseudorandom number.
  case utilPrng // = 86
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .cryptoTransfer
    case 2: self = .cryptoUpdate
    case 3: self = .cryptoDelete
    case 4: self = .cryptoAddLiveHash
    case 5: self = .cryptoDeleteLiveHash
    case 6: self = .contractCall
    case 7: self = .contractCreate
    case 8: self = .contractUpdate
    case 9: self = .fileCreate
    case 10: self = .fileAppend
    case 11: self = .fileUpdate
    case 12: self = .fileDelete
    case 13: self = .cryptoGetAccountBalance
    case 14: self = .cryptoGetAccountRecords
    case 15: self = .cryptoGetInfo
    case 16: self = .contractCallLocal
    case 17: self = .contractGetInfo
    case 18: self = .contractGetBytecode
    case 19: self = .getBySolidityID
    case 20: self = .getByKey
    case 21: self = .cryptoGetLiveHash
    case 22: self = .cryptoGetStakers
    case 23: self = .fileGetContents
    case 24: self = .fileGetInfo
    case 25: self = .transactionGetRecord
    case 26: self = .contractGetRecords
    case 27: self = .cryptoCreate
    case 28: self = .systemDelete
    case 29: self = .systemUndelete
    case 30: self = .contractDelete
    case 31: self = .freeze
    case 32: self = .createTransactionRecord
    case 33: self = .cryptoAccountAutoRenew
    case 34: self = .contractAutoRenew
    case 35: self = .getVersionInfo
    case 36: self = .transactionGetReceipt
    case 50: self = .consensusCreateTopic
    case 51: self = .consensusUpdateTopic
    case 52: self = .consensusDeleteTopic
    case 53: self = .consensusGetTopicInfo
    case 54: self = .consensusSubmitMessage
    case 55: self = .uncheckedSubmit
    case 56: self = .tokenCreate
    case 58: self = .tokenGetInfo
    case 59: self = .tokenFreezeAccount
    case 60: self = .tokenUnfreezeAccount
    case 61: self = .tokenGrantKycToAccount
    case 62: self = .tokenRevokeKycFromAccount
    case 63: self = .tokenDelete
    case 64: self = .tokenUpdate
    case 65: self = .tokenMint
    case 66: self = .tokenBurn
    case 67: self = .tokenAccountWipe
    case 68: self = .tokenAssociateToAccount
    case 69: self = .tokenDissociateFromAccount
    case 70: self = .scheduleCreate
    case 71: self = .scheduleDelete
    case 72: self = .scheduleSign
    case 73: self = .scheduleGetInfo
    case 74: self = .tokenGetAccountNftInfos
    case 75: self = .tokenGetNftInfo
    case 76: self = .tokenGetNftInfos
    case 77: self = .tokenFeeScheduleUpdate
    case 78: self = .networkGetExecutionTime
    case 79: self = .tokenPause
    case 80: self = .tokenUnpause
    case 81: self = .cryptoApproveAllowance
    case 82: self = .cryptoDeleteAllowance
    case 83: self = .getAccountDetails
    case 84: self = .ethereumTransaction
    case 85: self = .nodeStakeUpdate
    case 86: self = .utilPrng
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .cryptoTransfer: return 1
    case .cryptoUpdate: return 2
    case .cryptoDelete: return 3
    case .cryptoAddLiveHash: return 4
    case .cryptoDeleteLiveHash: return 5
    case .contractCall: return 6
    case .contractCreate: return 7
    case .contractUpdate: return 8
    case .fileCreate: return 9
    case .fileAppend: return 10
    case .fileUpdate: return 11
    case .fileDelete: return 12
    case .cryptoGetAccountBalance: return 13
    case .cryptoGetAccountRecords: return 14
    case .cryptoGetInfo: return 15
    case .contractCallLocal: return 16
    case .contractGetInfo: return 17
    case .contractGetBytecode: return 18
    case .getBySolidityID: return 19
    case .getByKey: return 20
    case .cryptoGetLiveHash: return 21
    case .cryptoGetStakers: return 22
    case .fileGetContents: return 23
    case .fileGetInfo: return 24
    case .transactionGetRecord: return 25
    case .contractGetRecords: return 26
    case .cryptoCreate: return 27
    case .systemDelete: return 28
    case .systemUndelete: return 29
    case .contractDelete: return 30
    case .freeze: return 31
    case .createTransactionRecord: return 32
    case .cryptoAccountAutoRenew: return 33
    case .contractAutoRenew: return 34
    case .getVersionInfo: return 35
    case .transactionGetReceipt: return 36
    case .consensusCreateTopic: return 50
    case .consensusUpdateTopic: return 51
    case .consensusDeleteTopic: return 52
    case .consensusGetTopicInfo: return 53
    case .consensusSubmitMessage: return 54
    case .uncheckedSubmit: return 55
    case .tokenCreate: return 56
    case .tokenGetInfo: return 58
    case .tokenFreezeAccount: return 59
    case .tokenUnfreezeAccount: return 60
    case .tokenGrantKycToAccount: return 61
    case .tokenRevokeKycFromAccount: return 62
    case .tokenDelete: return 63
    case .tokenUpdate: return 64
    case .tokenMint: return 65
    case .tokenBurn: return 66
    case .tokenAccountWipe: return 67
    case .tokenAssociateToAccount: return 68
    case .tokenDissociateFromAccount: return 69
    case .scheduleCreate: return 70
    case .scheduleDelete: return 71
    case .scheduleSign: return 72
    case .scheduleGetInfo: return 73
    case .tokenGetAccountNftInfos: return 74
    case .tokenGetNftInfo: return 75
    case .tokenGetNftInfos: return 76
    case .tokenFeeScheduleUpdate: return 77
    case .networkGetExecutionTime: return 78
    case .tokenPause: return 79
    case .tokenUnpause: return 80
    case .cryptoApproveAllowance: return 81
    case .cryptoDeleteAllowance: return 82
    case .getAccountDetails: return 83
    case .ethereumTransaction: return 84
    case .nodeStakeUpdate: return 85
    case .utilPrng: return 86
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_HederaFunctionality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_HederaFunctionality] = [
    .none,
    .cryptoTransfer,
    .cryptoUpdate,
    .cryptoDelete,
    .cryptoAddLiveHash,
    .cryptoDeleteLiveHash,
    .contractCall,
    .contractCreate,
    .contractUpdate,
    .fileCreate,
    .fileAppend,
    .fileUpdate,
    .fileDelete,
    .cryptoGetAccountBalance,
    .cryptoGetAccountRecords,
    .cryptoGetInfo,
    .contractCallLocal,
    .contractGetInfo,
    .contractGetBytecode,
    .getBySolidityID,
    .getByKey,
    .cryptoGetLiveHash,
    .cryptoGetStakers,
    .fileGetContents,
    .fileGetInfo,
    .transactionGetRecord,
    .contractGetRecords,
    .cryptoCreate,
    .systemDelete,
    .systemUndelete,
    .contractDelete,
    .freeze,
    .createTransactionRecord,
    .cryptoAccountAutoRenew,
    .contractAutoRenew,
    .getVersionInfo,
    .transactionGetReceipt,
    .consensusCreateTopic,
    .consensusUpdateTopic,
    .consensusDeleteTopic,
    .consensusGetTopicInfo,
    .consensusSubmitMessage,
    .uncheckedSubmit,
    .tokenCreate,
    .tokenGetInfo,
    .tokenFreezeAccount,
    .tokenUnfreezeAccount,
    .tokenGrantKycToAccount,
    .tokenRevokeKycFromAccount,
    .tokenDelete,
    .tokenUpdate,
    .tokenMint,
    .tokenBurn,
    .tokenAccountWipe,
    .tokenAssociateToAccount,
    .tokenDissociateFromAccount,
    .scheduleCreate,
    .scheduleDelete,
    .scheduleSign,
    .scheduleGetInfo,
    .tokenGetAccountNftInfos,
    .tokenGetNftInfo,
    .tokenGetNftInfos,
    .tokenFeeScheduleUpdate,
    .networkGetExecutionTime,
    .tokenPause,
    .tokenUnpause,
    .cryptoApproveAllowance,
    .cryptoDeleteAllowance,
    .getAccountDetails,
    .ethereumTransaction,
    .nodeStakeUpdate,
    .utilPrng,
  ]
}

#endif  // swift(>=4.2)

///*
/// Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative
/// realm number (that number might be reused in other shards). And each account, file, and smart
/// contract instance within a given realm has a nonnegative number (which might be reused in other
/// realms).  Every account, file, and smart contract instance is within exactly one realm. So a
/// FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.
/// Each realm maintains a single counter for assigning numbers,  so if there is a file with ID
/// 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
///
/// Everything is partitioned into realms so that each Solidity smart contract can  access everything
/// in just a single realm, locking all those entities while it's  running, but other smart contracts
/// could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized
/// somewhat, even though the  language itself assumes everything is serial.
public struct Proto_ShardID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// the shard number (nonnegative)
  public var shardNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and
/// contract instance belongs to exactly one realm.
public struct Proto_RealmID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The shard number (nonnegative)
  public var shardNum: Int64 = 0

  ///*
  /// The realm number (nonnegative)
  public var realmNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The ID for an a cryptocurrency account
public struct Proto_AccountID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The shard number (nonnegative)
  public var shardNum: Int64 = 0

  ///*
  /// The realm number (nonnegative)
  public var realmNum: Int64 = 0

  ///*
  /// The account number unique within its realm which can be a non-negative integer, an alias public key or an EVM address.
  /// For any AccountID fields in the query response, transaction record or transaction receipt only accountNum will
  /// be populated.
  public var account: Proto_AccountID.OneOf_Account? = nil

  ///*
  /// A non-negative account number unique within its realm
  public var accountNum: Int64 {
    get {
      if case .accountNum(let v)? = account {return v}
      return 0
    }
    set {account = .accountNum(newValue)}
  }

  ///*
  /// The public key bytes to be used as the account's alias. The public key bytes are the result of serializing
  /// a protobuf Key message for any primitive key type. Currently only primitive key bytes are supported as an alias
  /// (ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)
  ///
  /// At most one account can ever have a given alias and it is used for account creation if it
  /// was automatically created using a crypto transfer. It will be null if an account is created normally.
  /// It is immutable once it is set for an account.
  ///
  /// If a transaction auto-creates the account, any further transfers to that alias will simply be deposited
  /// in that account, without creating anything, and with no creation fee being charged.
  public var alias: Data {
    get {
      if case .alias(let v)? = account {return v}
      return Data()
    }
    set {account = .alias(newValue)}
  }

  ///*
  /// The ethereum account 20-byte EVM address to be used initially in place of the public key bytes. This EVM
  /// address may be either the encoded form of the shard.realm.num or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
  ///
  /// If a transaction lazily-creates this account, a subsequent transaction will be required containing the public key bytes
  /// that map to the EVM address bytes. Lazy account creates will only support the keccak-256 hash of a ECDSA_SECP256K1 primitive key form.
  public var evmAddress: Data {
    get {
      if case .evmAddress(let v)? = account {return v}
      return Data()
    }
    set {account = .evmAddress(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// The account number unique within its realm which can be a non-negative integer, an alias public key or an EVM address.
  /// For any AccountID fields in the query response, transaction record or transaction receipt only accountNum will
  /// be populated.
  public enum OneOf_Account: Equatable {
    ///*
    /// A non-negative account number unique within its realm
    case accountNum(Int64)
    ///*
    /// The public key bytes to be used as the account's alias. The public key bytes are the result of serializing
    /// a protobuf Key message for any primitive key type. Currently only primitive key bytes are supported as an alias
    /// (ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)
    ///
    /// At most one account can ever have a given alias and it is used for account creation if it
    /// was automatically created using a crypto transfer. It will be null if an account is created normally.
    /// It is immutable once it is set for an account.
    ///
    /// If a transaction auto-creates the account, any further transfers to that alias will simply be deposited
    /// in that account, without creating anything, and with no creation fee being charged.
    case alias(Data)
    ///*
    /// The ethereum account 20-byte EVM address to be used initially in place of the public key bytes. This EVM
    /// address may be either the encoded form of the shard.realm.num or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
    ///
    /// If a transaction lazily-creates this account, a subsequent transaction will be required containing the public key bytes
    /// that map to the EVM address bytes. Lazy account creates will only support the keccak-256 hash of a ECDSA_SECP256K1 primitive key form.
    case evmAddress(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_AccountID.OneOf_Account, rhs: Proto_AccountID.OneOf_Account) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.accountNum, .accountNum): return {
        guard case .accountNum(let l) = lhs, case .accountNum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.alias, .alias): return {
        guard case .alias(let l) = lhs, case .alias(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.evmAddress, .evmAddress): return {
        guard case .evmAddress(let l) = lhs, case .evmAddress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///*
/// The ID for a file
public struct Proto_FileID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The shard number (nonnegative)
  public var shardNum: Int64 = 0

  ///*
  /// The realm number (nonnegative)
  public var realmNum: Int64 = 0

  ///*
  /// A nonnegative File number unique within its realm
  public var fileNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The ID for a smart contract instance
public struct Proto_ContractID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The shard number (nonnegative)
  public var shardNum: Int64 = 0

  ///*
  /// The realm number (nonnegative)
  public var realmNum: Int64 = 0

  public var contract: Proto_ContractID.OneOf_Contract? = nil

  ///*
  /// A nonnegative number unique within a given shard and realm
  public var contractNum: Int64 {
    get {
      if case .contractNum(let v)? = contract {return v}
      return 0
    }
    set {contract = .contractNum(newValue)}
  }

  ///*
  /// The 20-byte EVM address of the contract to call.
  ///
  /// Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
  /// This address is as follows:
  ///   <ol>
  ///     <li>The first 4 bytes are the big-endian representation of the shard.</li>
  ///     <li>The next 8 bytes are the big-endian representation of the realm.</li>
  ///     <li>The final 8 bytes are the big-endian representation of the number.</li>
  ///   </ol>
  ///
  /// Contracts created via CREATE2 have an <b>additional, primary address</b> that is
  /// derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
  /// specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
  ///
  /// (Please do note that CREATE2 contracts can also be referenced by the three-part
  /// EVM address described above.)
  public var evmAddress: Data {
    get {
      if case .evmAddress(let v)? = contract {return v}
      return Data()
    }
    set {contract = .evmAddress(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Contract: Equatable {
    ///*
    /// A nonnegative number unique within a given shard and realm
    case contractNum(Int64)
    ///*
    /// The 20-byte EVM address of the contract to call.
    ///
    /// Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
    /// This address is as follows:
    ///   <ol>
    ///     <li>The first 4 bytes are the big-endian representation of the shard.</li>
    ///     <li>The next 8 bytes are the big-endian representation of the realm.</li>
    ///     <li>The final 8 bytes are the big-endian representation of the number.</li>
    ///   </ol>
    ///
    /// Contracts created via CREATE2 have an <b>additional, primary address</b> that is
    /// derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
    /// specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
    ///
    /// (Please do note that CREATE2 contracts can also be referenced by the three-part
    /// EVM address described above.)
    case evmAddress(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_ContractID.OneOf_Contract, rhs: Proto_ContractID.OneOf_Contract) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contractNum, .contractNum): return {
        guard case .contractNum(let l) = lhs, case .contractNum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.evmAddress, .evmAddress): return {
        guard case .evmAddress(let l) = lhs, case .evmAddress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///*
/// The ID for a transaction. This is used for retrieving receipts and records for a transaction, for
/// appending to a file right after creating it, for instantiating a smart contract with bytecode in
/// a file just created, and internally by the network for detecting when duplicate transactions are
/// submitted. A user might get a transaction processed faster by submitting it to N nodes, each with
/// a different node account, but all with the same TransactionID. Then, the transaction will take
/// effect when the first of all those nodes submits the transaction and it reaches consensus. The
/// other transactions will not take effect. So this could make the transaction take effect faster,
/// if any given node might be slow. However, the full transaction fee is charged for each
/// transaction, so the total fee is N times as much if the transaction is sent to N nodes.
///
/// Applicable to Scheduled Transactions:
///  - The ID of a Scheduled Transaction has transactionValidStart and accountIDs inherited from the
///    ScheduleCreate transaction that created it. That is to say that they are equal
///  - The scheduled property is true for Scheduled Transactions
///  - transactionValidStart, accountID and scheduled properties should be omitted
public struct Proto_TransactionID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
  public var transactionValidStart: Proto_Timestamp {
    get {return _transactionValidStart ?? Proto_Timestamp()}
    set {_transactionValidStart = newValue}
  }
  /// Returns true if `transactionValidStart` has been explicitly set.
  public var hasTransactionValidStart: Bool {return self._transactionValidStart != nil}
  /// Clears the value of `transactionValidStart`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionValidStart() {self._transactionValidStart = nil}

  ///*
  /// The Account ID that paid for this transaction
  public var accountID: Proto_AccountID {
    get {return _accountID ?? Proto_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  ///*
  /// Whether the Transaction is of type Scheduled or no
  public var scheduled: Bool = false

  ///*
  /// The identifier for an internal transaction that was spawned as part
  /// of handling a user transaction. (These internal transactions share the
  /// transactionValidStart and accountID of the user transaction, so a
  /// nonce is necessary to give them a unique TransactionID.)
  ///
  /// An example is when a "parent" ContractCreate or ContractCall transaction
  /// calls one or more HTS precompiled contracts; each of the "child"
  /// transactions spawned for a precompile has a id with a different nonce.
  public var nonce: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transactionValidStart: Proto_Timestamp? = nil
  fileprivate var _accountID: Proto_AccountID? = nil
}

///*
/// An account, and the amount that it sends or receives during a cryptocurrency or token transfer.
public struct Proto_AccountAmount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The Account ID that sends/receives cryptocurrency or tokens
  public var accountID: Proto_AccountID {
    get {return _accountID ?? Proto_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  ///*
  /// The amount of tinybars (for Crypto transfers) or in the lowest
  /// denomination (for Token transfers) that the account sends(negative) or
  /// receives(positive)
  public var amount: Int64 = 0

  ///*
  /// If true then the transfer is expected to be an approved allowance and the
  /// accountID is expected to be the owner. The default is false (omitted).
  public var isApproval: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _accountID: Proto_AccountID? = nil
}

///*
/// A list of accounts and amounts to transfer out of each account (negative) or into it (positive).
public struct Proto_TransferList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Multiple list of AccountAmount pairs, each of which has an account and
  /// an amount to transfer into it (positive) or out of it (negative)
  public var accountAmounts: [Proto_AccountAmount] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A sender account, a receiver account, and the serial number of an NFT of a Token with
/// NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance
/// (0.0.0) and when burning NFTs, the receiver will be the default AccountID instance.
public struct Proto_NftTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The accountID of the sender
  public var senderAccountID: Proto_AccountID {
    get {return _senderAccountID ?? Proto_AccountID()}
    set {_senderAccountID = newValue}
  }
  /// Returns true if `senderAccountID` has been explicitly set.
  public var hasSenderAccountID: Bool {return self._senderAccountID != nil}
  /// Clears the value of `senderAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearSenderAccountID() {self._senderAccountID = nil}

  ///*
  /// The accountID of the receiver
  public var receiverAccountID: Proto_AccountID {
    get {return _receiverAccountID ?? Proto_AccountID()}
    set {_receiverAccountID = newValue}
  }
  /// Returns true if `receiverAccountID` has been explicitly set.
  public var hasReceiverAccountID: Bool {return self._receiverAccountID != nil}
  /// Clears the value of `receiverAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearReceiverAccountID() {self._receiverAccountID = nil}

  ///*
  /// The serial number of the NFT
  public var serialNumber: Int64 = 0

  ///*
  /// If true then the transfer is expected to be an approved allowance and the
  /// senderAccountID is expected to be the owner. The default is false (omitted).
  public var isApproval: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _senderAccountID: Proto_AccountID? = nil
  fileprivate var _receiverAccountID: Proto_AccountID? = nil
}

///*
/// A list of token IDs and amounts representing the transferred out (negative) or into (positive)
/// amounts, represented in the lowest denomination of the token
public struct Proto_TokenTransferList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The ID of the token
  public var token: Proto_TokenID {
    get {return _token ?? Proto_TokenID()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  ///*
  /// Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which
  /// has an account and amount
  public var transfers: [Proto_AccountAmount] = []

  ///*
  /// Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of
  /// which has a sender and receiver account, including the serial number of the NFT
  public var nftTransfers: [Proto_NftTransfer] = []

  ///*
  /// If present, the number of decimals this fungible token type is expected to have. The transfer
  /// will fail with UNEXPECTED_TOKEN_DECIMALS if the actual decimals differ.
  public var expectedDecimals: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _expectedDecimals ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_expectedDecimals = newValue}
  }
  /// Returns true if `expectedDecimals` has been explicitly set.
  public var hasExpectedDecimals: Bool {return self._expectedDecimals != nil}
  /// Clears the value of `expectedDecimals`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedDecimals() {self._expectedDecimals = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Proto_TokenID? = nil
  fileprivate var _expectedDecimals: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

///*
/// A rational number, used to set the amount of a value transfer to collect as a custom fee
public struct Proto_Fraction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The rational's numerator
  public var numerator: Int64 = 0

  ///*
  /// The rational's denominator; a zero value will result in FRACTION_DIVIDES_BY_ZERO
  public var denominator: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Unique identifier for a topic (used by the consensus service)
public struct Proto_TopicID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The shard number (nonnegative)
  public var shardNum: Int64 = 0

  ///*
  /// The realm number (nonnegative)
  public var realmNum: Int64 = 0

  ///*
  /// Unique topic identifier within a realm (nonnegative).
  public var topicNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Unique identifier for a token
public struct Proto_TokenID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A nonnegative shard number
  public var shardNum: Int64 = 0

  ///*
  /// A nonnegative realm number
  public var realmNum: Int64 = 0

  ///*
  /// A nonnegative token number
  public var tokenNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Unique identifier for a Schedule
public struct Proto_ScheduleID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A nonnegative shard number
  public var shardNum: Int64 = 0

  ///*
  /// A nonnegative realm number
  public var realmNum: Int64 = 0

  ///*
  /// A nonnegative schedule number
  public var scheduleNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where
/// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call
/// these public keys <b>primitive keys</b>.
///
/// If an account has primitive key associated to it, then the corresponding private key must sign
/// any transaction to transfer cryptocurrency out of it.
///
/// A Key can also be the ID of a smart contract instance, which is then authorized to perform any
/// precompiled contract action that requires this key to sign.
///
/// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID
/// will actually create a cryptographic signature. It only means that when the contract calls a
/// precompiled contract, the resulting "child transaction" will be authorized to perform any action
/// controlled by the Key.
///
/// A Key can be a "threshold key", which means a list of M keys, any N of which must sign in order
/// for the threshold signature to be considered valid. The keys within a threshold signature may
/// themselves be threshold signatures, to allow complex signature requirements.
///
/// A Key can be a "key list" where all keys in the list must sign unless specified otherwise in the
/// documentation for a specific transaction type (e.g.  FileDeleteTransactionBody).  Their use is
/// dependent on context. For example, a Hedera file is created with a list of keys, where all of
/// them must sign a transaction to create or modify the file, but only one of them is needed to sign
/// a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold
/// key, and sometimes acts as an M-of-M threshold key.  A key list is always an M-of-M, unless
/// specified otherwise in documentation. A key list can have nested key lists or threshold keys.
/// Nested key lists are always M-of-M. A key list can have repeated primitive public keys, but all
/// repeated keys are only required to sign once.
///
/// A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual
/// recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive
/// keys has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive
/// keys has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels:
/// Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
///
/// Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
public struct Proto_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Proto_Key.OneOf_Key? = nil

  ///*
  /// smart contract instance that is authorized as if it had signed with a key
  public var contractID: Proto_ContractID {
    get {
      if case .contractID(let v)? = key {return v}
      return Proto_ContractID()
    }
    set {key = .contractID(newValue)}
  }

  ///*
  /// Ed25519 public key bytes
  public var ed25519: Data {
    get {
      if case .ed25519(let v)? = key {return v}
      return Data()
    }
    set {key = .ed25519(newValue)}
  }

  ///*
  /// (NOT SUPPORTED) RSA-3072 public key bytes
  public var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = key {return v}
      return Data()
    }
    set {key = .rsa3072(newValue)}
  }

  ///*
  /// (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes
  public var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = key {return v}
      return Data()
    }
    set {key = .ecdsa384(newValue)}
  }

  ///*
  /// a threshold N followed by a list of M keys, any N of which are required to form a valid
  /// signature
  public var thresholdKey: Proto_ThresholdKey {
    get {
      if case .thresholdKey(let v)? = key {return v}
      return Proto_ThresholdKey()
    }
    set {key = .thresholdKey(newValue)}
  }

  ///*
  /// A list of Keys of the Key type.
  public var keyList: Proto_KeyList {
    get {
      if case .keyList(let v)? = key {return v}
      return Proto_KeyList()
    }
    set {key = .keyList(newValue)}
  }

  ///*
  /// Compressed ECDSA(secp256k1) public key bytes
  public var ecdsaSecp256K1: Data {
    get {
      if case .ecdsaSecp256K1(let v)? = key {return v}
      return Data()
    }
    set {key = .ecdsaSecp256K1(newValue)}
  }

  ///*
  /// A smart contract that, if the recipient of the active message frame, should be treated
  /// as having signed. (Note this does not mean the <i>code being executed in the frame</i>
  /// will belong to the given contract, since it could be running another contract's code via
  /// <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the
  /// contractID key, which also requires the code in the active message frame belong to the
  /// the contract with the given id.)
  public var delegatableContractID: Proto_ContractID {
    get {
      if case .delegatableContractID(let v)? = key {return v}
      return Proto_ContractID()
    }
    set {key = .delegatableContractID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable {
    ///*
    /// smart contract instance that is authorized as if it had signed with a key
    case contractID(Proto_ContractID)
    ///*
    /// Ed25519 public key bytes
    case ed25519(Data)
    ///*
    /// (NOT SUPPORTED) RSA-3072 public key bytes
    case rsa3072(Data)
    ///*
    /// (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes
    case ecdsa384(Data)
    ///*
    /// a threshold N followed by a list of M keys, any N of which are required to form a valid
    /// signature
    case thresholdKey(Proto_ThresholdKey)
    ///*
    /// A list of Keys of the Key type.
    case keyList(Proto_KeyList)
    ///*
    /// Compressed ECDSA(secp256k1) public key bytes
    case ecdsaSecp256K1(Data)
    ///*
    /// A smart contract that, if the recipient of the active message frame, should be treated
    /// as having signed. (Note this does not mean the <i>code being executed in the frame</i>
    /// will belong to the given contract, since it could be running another contract's code via
    /// <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the
    /// contractID key, which also requires the code in the active message frame belong to the
    /// the contract with the given id.)
    case delegatableContractID(Proto_ContractID)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_Key.OneOf_Key, rhs: Proto_Key.OneOf_Key) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contractID, .contractID): return {
        guard case .contractID(let l) = lhs, case .contractID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ed25519, .ed25519): return {
        guard case .ed25519(let l) = lhs, case .ed25519(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rsa3072, .rsa3072): return {
        guard case .rsa3072(let l) = lhs, case .rsa3072(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ecdsa384, .ecdsa384): return {
        guard case .ecdsa384(let l) = lhs, case .ecdsa384(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.thresholdKey, .thresholdKey): return {
        guard case .thresholdKey(let l) = lhs, case .thresholdKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyList, .keyList): return {
        guard case .keyList(let l) = lhs, case .keyList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ecdsaSecp256K1, .ecdsaSecp256K1): return {
        guard case .ecdsaSecp256K1(let l) = lhs, case .ecdsaSecp256K1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delegatableContractID, .delegatableContractID): return {
        guard case .delegatableContractID(let l) = lhs, case .delegatableContractID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///*
/// A set of public keys that are used together to form a threshold signature.  If the threshold is N
/// and there are M keys, then this is an N of M threshold signature. If an account is associated
/// with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list
/// of M signatures, where at most M-N of them are blank, and the other at least N of them are valid
/// signatures corresponding to at least N of the public keys listed here.
public struct Proto_ThresholdKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A valid signature set must have at least this many signatures
  public var threshold: UInt32 = 0

  ///*
  /// List of all the keys that can sign
  public var keys: Proto_KeyList {
    get {return _keys ?? Proto_KeyList()}
    set {_keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  public var hasKeys: Bool {return self._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  public mutating func clearKeys() {self._keys = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keys: Proto_KeyList? = nil
}

///*
/// A list of keys that requires all keys (M-of-M) to sign unless otherwise specified in
/// documentation. A KeyList may contain repeated keys, but all repeated keys are only required to
/// sign once.
public struct Proto_KeyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// list of keys
  public var keys: [Proto_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
/// here only for historical reasons.
///
/// Please use the SignaturePair and SignatureMap messages.
public struct Proto_Signature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signature: Proto_Signature.OneOf_Signature? = nil

  ///*
  /// smart contract virtual signature (always length zero)
  public var contract: Data {
    get {
      if case .contract(let v)? = signature {return v}
      return Data()
    }
    set {signature = .contract(newValue)}
  }

  ///*
  /// ed25519 signature bytes
  public var ed25519: Data {
    get {
      if case .ed25519(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ed25519(newValue)}
  }

  ///*
  /// RSA-3072 signature bytes
  public var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = signature {return v}
      return Data()
    }
    set {signature = .rsa3072(newValue)}
  }

  ///*
  /// ECDSA p-384 signature bytes
  public var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ecdsa384(newValue)}
  }

  ///*
  /// A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
  /// signatures, at least N of which are non-null.
  public var thresholdSignature: Proto_ThresholdSignature {
    get {
      if case .thresholdSignature(let v)? = signature {return v}
      return Proto_ThresholdSignature()
    }
    set {signature = .thresholdSignature(newValue)}
  }

  ///*
  /// A list of M signatures, each corresponding to a Key in a KeyList of the same length.
  public var signatureList: Proto_SignatureList {
    get {
      if case .signatureList(let v)? = signature {return v}
      return Proto_SignatureList()
    }
    set {signature = .signatureList(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Signature: Equatable {
    ///*
    /// smart contract virtual signature (always length zero)
    case contract(Data)
    ///*
    /// ed25519 signature bytes
    case ed25519(Data)
    ///*
    /// RSA-3072 signature bytes
    case rsa3072(Data)
    ///*
    /// ECDSA p-384 signature bytes
    case ecdsa384(Data)
    ///*
    /// A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
    /// signatures, at least N of which are non-null.
    case thresholdSignature(Proto_ThresholdSignature)
    ///*
    /// A list of M signatures, each corresponding to a Key in a KeyList of the same length.
    case signatureList(Proto_SignatureList)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_Signature.OneOf_Signature, rhs: Proto_Signature.OneOf_Signature) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contract, .contract): return {
        guard case .contract(let l) = lhs, case .contract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ed25519, .ed25519): return {
        guard case .ed25519(let l) = lhs, case .ed25519(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rsa3072, .rsa3072): return {
        guard case .rsa3072(let l) = lhs, case .rsa3072(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ecdsa384, .ecdsa384): return {
        guard case .ecdsa384(let l) = lhs, case .ecdsa384(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.thresholdSignature, .thresholdSignature): return {
        guard case .thresholdSignature(let l) = lhs, case .thresholdSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.signatureList, .signatureList): return {
        guard case .signatureList(let l) = lhs, case .signatureList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///*
/// This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
/// here only for historical reasons.
///
/// Please use the SignaturePair and SignatureMap messages.
public struct Proto_ThresholdSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// for an N-of-M threshold key, this is a list of M signatures, at least N of which must be
  /// non-null
  public var sigs: Proto_SignatureList {
    get {return _sigs ?? Proto_SignatureList()}
    set {_sigs = newValue}
  }
  /// Returns true if `sigs` has been explicitly set.
  public var hasSigs: Bool {return self._sigs != nil}
  /// Clears the value of `sigs`. Subsequent reads from it will return its default value.
  public mutating func clearSigs() {self._sigs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sigs: Proto_SignatureList? = nil
}

///*
/// This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
/// here only for historical reasons.
///
/// Please use the SignaturePair and SignatureMap messages.
public struct Proto_SignatureList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// each signature corresponds to a Key in the KeyList
  public var sigs: [Proto_Signature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The client may use any number of bytes from zero to the whole length of the public key for
/// pubKeyPrefix. If zero bytes are used, then it must be that only one primitive key is required
/// to sign the linked transaction; it will surely resolve to <tt>INVALID_SIGNATURE</tt> otherwise.
///
/// <b>IMPORTANT:</b> In the special case that a signature is being provided for a key used to
/// authorize a precompiled contract, the <tt>pubKeyPrefix</tt> must contain the <b>entire public
/// key</b>! That is, if the key is a Ed25519 key, the <tt>pubKeyPrefix</tt> should be 32 bytes
/// long. If the key is a ECDSA(secp256k1) key, the <tt>pubKeyPrefix</tt> should be 33 bytes long,
/// since we require the compressed form of the public key.
///
/// Only Ed25519 and ECDSA(secp256k1) keys and hence signatures are currently supported.
public struct Proto_SignaturePair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// First few bytes of the public key
  public var pubKeyPrefix: Data = Data()

  public var signature: Proto_SignaturePair.OneOf_Signature? = nil

  ///*
  /// smart contract virtual signature (always length zero)
  public var contract: Data {
    get {
      if case .contract(let v)? = signature {return v}
      return Data()
    }
    set {signature = .contract(newValue)}
  }

  ///*
  /// ed25519 signature
  public var ed25519: Data {
    get {
      if case .ed25519(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ed25519(newValue)}
  }

  ///*
  /// RSA-3072 signature
  public var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = signature {return v}
      return Data()
    }
    set {signature = .rsa3072(newValue)}
  }

  ///*
  /// ECDSA p-384 signature
  public var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ecdsa384(newValue)}
  }

  ///*
  /// ECDSA(secp256k1) signature
  public var ecdsaSecp256K1: Data {
    get {
      if case .ecdsaSecp256K1(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ecdsaSecp256K1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Signature: Equatable {
    ///*
    /// smart contract virtual signature (always length zero)
    case contract(Data)
    ///*
    /// ed25519 signature
    case ed25519(Data)
    ///*
    /// RSA-3072 signature
    case rsa3072(Data)
    ///*
    /// ECDSA p-384 signature
    case ecdsa384(Data)
    ///*
    /// ECDSA(secp256k1) signature
    case ecdsaSecp256K1(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_SignaturePair.OneOf_Signature, rhs: Proto_SignaturePair.OneOf_Signature) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contract, .contract): return {
        guard case .contract(let l) = lhs, case .contract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ed25519, .ed25519): return {
        guard case .ed25519(let l) = lhs, case .ed25519(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rsa3072, .rsa3072): return {
        guard case .rsa3072(let l) = lhs, case .rsa3072(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ecdsa384, .ecdsa384): return {
        guard case .ecdsa384(let l) = lhs, case .ecdsa384(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ecdsaSecp256K1, .ecdsaSecp256K1): return {
        guard case .ecdsaSecp256K1(let l) = lhs, case .ecdsaSecp256K1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

///*
/// A set of signatures corresponding to every unique public key used to sign a given transaction. If
/// one public key matches more than one prefixes on the signature map, the transaction containing
/// the map will fail immediately with the response code KEY_PREFIX_MISMATCH.
public struct Proto_SignatureMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Each signature pair corresponds to a unique Key required to sign the transaction.
  public var sigPair: [Proto_SignaturePair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A set of prices the nodes use in determining transaction and query fees, and constants involved
/// in fee calculations.  Nodes multiply the amount of resources consumed by a transaction or query
/// by the corresponding price to calculate the appropriate fee. Units are one-thousandth of a
/// tinyCent.
public struct Proto_FeeComponents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A minimum, the calculated fee must be greater than this value
  public var min: Int64 = 0

  ///*
  /// A maximum, the calculated fee must be less than this value
  public var max: Int64 = 0

  ///*
  /// A constant contribution to the fee
  public var constant: Int64 = 0

  ///*
  /// The price of bandwidth consumed by a transaction, measured in bytes
  public var bpt: Int64 = 0

  ///*
  /// The price per signature verification for a transaction
  public var vpt: Int64 = 0

  ///*
  /// The price of RAM consumed by a transaction, measured in byte-hours
  public var rbh: Int64 = 0

  ///*
  /// The price of storage consumed by a transaction, measured in byte-hours
  public var sbh: Int64 = 0

  ///*
  /// The price of computation for a smart contract transaction, measured in gas
  public var gas: Int64 = 0

  ///*
  /// The price per hbar transferred for a transfer
  public var tv: Int64 = 0

  ///*
  /// The price of bandwidth for data retrieved from memory for a response, measured in bytes
  public var bpr: Int64 = 0

  ///*
  /// The price of bandwidth for data retrieved from disk for a response, measured in bytes
  public var sbpr: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The fees for a specific transaction or query based on the fee data.
public struct Proto_TransactionFeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A particular transaction or query
  public var hederaFunctionality: Proto_HederaFunctionality = .none

  ///*
  /// Resource price coefficients
  public var feeData: Proto_FeeData {
    get {return _feeData ?? Proto_FeeData()}
    set {_feeData = newValue}
  }
  /// Returns true if `feeData` has been explicitly set.
  public var hasFeeData: Bool {return self._feeData != nil}
  /// Clears the value of `feeData`. Subsequent reads from it will return its default value.
  public mutating func clearFeeData() {self._feeData = nil}

  ///*
  /// Resource price coefficients. Supports subtype price definition.
  public var fees: [Proto_FeeData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feeData: Proto_FeeData? = nil
}

///*
/// The total fee charged for a transaction. It is composed of three components  a node fee that
/// compensates the specific node that submitted the transaction, a network fee that compensates the
/// network for assigning the transaction a consensus timestamp, and a service fee that compensates
/// the network for the ongoing maintenance of the consequences of the transaction.
public struct Proto_FeeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Fee paid to the submitting node
  public var nodedata: Proto_FeeComponents {
    get {return _storage._nodedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._nodedata = newValue}
  }
  /// Returns true if `nodedata` has been explicitly set.
  public var hasNodedata: Bool {return _storage._nodedata != nil}
  /// Clears the value of `nodedata`. Subsequent reads from it will return its default value.
  public mutating func clearNodedata() {_uniqueStorage()._nodedata = nil}

  ///*
  /// Fee paid to the network for processing a transaction into consensus
  public var networkdata: Proto_FeeComponents {
    get {return _storage._networkdata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._networkdata = newValue}
  }
  /// Returns true if `networkdata` has been explicitly set.
  public var hasNetworkdata: Bool {return _storage._networkdata != nil}
  /// Clears the value of `networkdata`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkdata() {_uniqueStorage()._networkdata = nil}

  ///*
  /// Fee paid to the network for providing the service associated with the
  /// transaction; for instance, storing a file
  public var servicedata: Proto_FeeComponents {
    get {return _storage._servicedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._servicedata = newValue}
  }
  /// Returns true if `servicedata` has been explicitly set.
  public var hasServicedata: Bool {return _storage._servicedata != nil}
  /// Clears the value of `servicedata`. Subsequent reads from it will return its default value.
  public mutating func clearServicedata() {_uniqueStorage()._servicedata = nil}

  ///*
  /// SubType distinguishing between different types of FeeData, correlating
  /// to the same HederaFunctionality
  public var subType: Proto_SubType {
    get {return _storage._subType}
    set {_uniqueStorage()._subType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A list of resource prices fee for different transactions and queries and the time period at which
/// this fee schedule will expire. Nodes use the prices to determine the fees for all transactions
/// based on how much of those resources each transaction uses.
public struct Proto_FeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// List of price coefficients for network resources
  public var transactionFeeSchedule: [Proto_TransactionFeeSchedule] = []

  ///*
  /// FeeSchedule expiry time
  public var expiryTime: Proto_TimestampSeconds {
    get {return _expiryTime ?? Proto_TimestampSeconds()}
    set {_expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  public var hasExpiryTime: Bool {return self._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpiryTime() {self._expiryTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiryTime: Proto_TimestampSeconds? = nil
}

///*
/// This contains two Fee Schedules with expiry timestamp.
public struct Proto_CurrentAndNextFeeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Contains current Fee Schedule
  public var currentFeeSchedule: Proto_FeeSchedule {
    get {return _currentFeeSchedule ?? Proto_FeeSchedule()}
    set {_currentFeeSchedule = newValue}
  }
  /// Returns true if `currentFeeSchedule` has been explicitly set.
  public var hasCurrentFeeSchedule: Bool {return self._currentFeeSchedule != nil}
  /// Clears the value of `currentFeeSchedule`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentFeeSchedule() {self._currentFeeSchedule = nil}

  ///*
  /// Contains next Fee Schedule
  public var nextFeeSchedule: Proto_FeeSchedule {
    get {return _nextFeeSchedule ?? Proto_FeeSchedule()}
    set {_nextFeeSchedule = newValue}
  }
  /// Returns true if `nextFeeSchedule` has been explicitly set.
  public var hasNextFeeSchedule: Bool {return self._nextFeeSchedule != nil}
  /// Clears the value of `nextFeeSchedule`. Subsequent reads from it will return its default value.
  public mutating func clearNextFeeSchedule() {self._nextFeeSchedule = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentFeeSchedule: Proto_FeeSchedule? = nil
  fileprivate var _nextFeeSchedule: Proto_FeeSchedule? = nil
}

///*
/// Contains the IP address and the port representing a service endpoint of a Node in a network. Used
/// to reach the Hedera API and submit transactions to the network.
public struct Proto_ServiceEndpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The 32-bit IPv4 address of the node encoded in left to right order (e.g.  127.0.0.1 has 127
  /// as its first byte)
  public var ipAddressV4: Data = Data()

  ///*
  /// The port of the node
  public var port: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The data about a node, including its service endpoints and the Hedera account to be paid for
/// services provided by the node (that is, queries answered and transactions submitted.)
///
/// If the <tt>serviceEndpoint</tt> list is not set, or empty, then the endpoint given by the
/// (deprecated) <tt>ipAddress</tt> and <tt>portno</tt> fields should be used.
///
/// All fields are populated in the 0.0.102 address book file while only fields that start with # are
/// populated in the 0.0.101 address book file.
public struct Proto_NodeAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The IP address of the Node with separator & octets encoded in UTF-8.  Usage is deprecated,
  /// ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports
  public var ipAddress: Data = Data()

  ///*
  /// The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is
  /// preferred to retrieve a node's list of IP addresses and ports
  public var portno: Int32 = 0

  ///*
  /// Usage is deprecated, nodeAccountId is preferred to retrieve a node's account ID
  public var memo: Data = Data()

  ///*
  /// The node's X509 RSA public key used to sign stream files (e.g., record stream
  /// files). Precisely, this field is a string of hexadecimal characters which,
  /// translated to binary, are the public key's DER encoding.
  public var rsaPubKey: String = String()

  ///*
  /// # A non-sequential identifier for the node
  public var nodeID: Int64 = 0

  ///*
  /// # The account to be paid for queries and transactions sent to this node
  public var nodeAccountID: Proto_AccountID {
    get {return _nodeAccountID ?? Proto_AccountID()}
    set {_nodeAccountID = newValue}
  }
  /// Returns true if `nodeAccountID` has been explicitly set.
  public var hasNodeAccountID: Bool {return self._nodeAccountID != nil}
  /// Clears the value of `nodeAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearNodeAccountID() {self._nodeAccountID = nil}

  ///*
  /// # Hash of the node's TLS certificate. Precisely, this field is a string of
  /// hexadecimal characters which, translated to binary, are the SHA-384 hash of
  /// the UTF-8 NFKD encoding of the node's TLS cert in PEM format. Its value can be
  /// used to verify the node's certificate it presents during TLS negotiations.
  public var nodeCertHash: Data = Data()

  ///*
  /// # A node's service IP addresses and ports
  public var serviceEndpoint: [Proto_ServiceEndpoint] = []

  ///*
  /// A description of the node, with UTF-8 encoding up to 100 bytes
  public var description_p: String = String()

  ///*
  /// [Deprecated] The amount of tinybars staked to the node
  public var stake: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeAccountID: Proto_AccountID? = nil
}

///*
/// A list of nodes and their metadata that contains all details of the nodes for the network.  Used
/// to parse the contents of system files <tt>0.0.101</tt> and <tt>0.0.102</tt>.
public struct Proto_NodeAddressBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Metadata of all nodes in the network
  public var nodeAddress: [Proto_NodeAddress] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Hedera follows semantic versioning (https://semver.org/) for both the HAPI protobufs and the
/// Services software.  This type allows the <tt>getVersionInfo</tt> query in the
/// <tt>NetworkService</tt> to return the deployed versions of both protobufs and software on the
/// node answering the query.
public struct Proto_SemanticVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Increases with incompatible API changes
  public var major: Int32 = 0

  ///*
  /// Increases with backwards-compatible new functionality
  public var minor: Int32 = 0

  ///*
  /// Increases with backwards-compatible bug fixes
  public var patch: Int32 = 0

  ///*
  /// A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
  /// identifiers (https://semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1+21AF26D3,
  /// this field would contain 'alpha.1'
  public var pre: String = String()

  ///*
  /// Build metadata MAY be denoted by appending a plus sign and a series of dot separated
  /// identifiers immediately following the patch or pre-release version
  /// (https://semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1+21AF26D3, this field
  /// would contain '21AF26D3'
  public var build: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// UNDOCUMENTED
public struct Proto_Setting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// name of the property
  public var name: String = String()

  ///*
  /// value of the property
  public var value: String = String()

  ///*
  /// any data associated with property
  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// UNDOCUMENTED
public struct Proto_ServicesConfigurationList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// list of name value pairs of the application properties
  public var nameValue: [Proto_Setting] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Token's information related to the given Account
public struct Proto_TokenRelationship {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The ID of the token
  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  ///*
  /// The Symbol of the token
  public var symbol: String = String()

  ///*
  /// For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest
  /// denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
  public var balance: UInt64 = 0

  ///*
  /// The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not
  /// have KYC key, KycNotApplicable is returned
  public var kycStatus: Proto_TokenKycStatus = .kycNotApplicable

  ///*
  /// The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does
  /// not have Freeze key, FreezeNotApplicable is returned
  public var freezeStatus: Proto_TokenFreezeStatus = .freezeNotApplicable

  ///*
  /// Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
  public var decimals: UInt32 = 0

  ///*
  /// Specifies if the relationship is created implicitly. False : explicitly associated, True :
  /// implicitly associated.
  public var automaticAssociation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
}

///*
/// A number of <i>transferable units</i> of a certain token.
///
/// The transferable unit of a token is its smallest denomination, as given by the token's
/// <tt>decimals</tt> property---each minted token contains <tt>10<sup>decimals</sup></tt>
/// transferable units. For example, we could think of the cent as the transferable unit of the US
/// dollar (<tt>decimals=2</tt>); and the tinybar as the transferable unit of hbar
/// (<tt>decimals=8</tt>).
///
/// Transferable units are not directly comparable across different tokens.
public struct Proto_TokenBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A unique token id
  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  ///*
  /// Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
  /// balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
  /// NFTs held by the account
  public var balance: UInt64 = 0

  ///*
  /// Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
  public var decimals: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
}

///*
/// A sequence of token balances
public struct Proto_TokenBalances {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokenBalances: [Proto_TokenBalance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A token - account association
public struct Proto_TokenAssociation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The token involved in the association
  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  /// The account involved in the association
  public var accountID: Proto_AccountID {
    get {return _accountID ?? Proto_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
  fileprivate var _accountID: Proto_AccountID? = nil
}

///*
/// Staking metadata for an account or a contract returned in CryptoGetInfo or ContractGetInfo queries
public struct Proto_StakingInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// If true, this account or contract declined to receive a staking reward.
  public var declineReward: Bool = false

  ///*
  /// The staking period during which either the staking settings for this account or contract changed (such as starting
  /// staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
  /// is not currently staked to a node, then this field is not set.
  public var stakePeriodStart: Proto_Timestamp {
    get {return _stakePeriodStart ?? Proto_Timestamp()}
    set {_stakePeriodStart = newValue}
  }
  /// Returns true if `stakePeriodStart` has been explicitly set.
  public var hasStakePeriodStart: Bool {return self._stakePeriodStart != nil}
  /// Clears the value of `stakePeriodStart`. Subsequent reads from it will return its default value.
  public mutating func clearStakePeriodStart() {self._stakePeriodStart = nil}

  ///*
  /// The amount in tinybars that will be received in the next reward situation.
  public var pendingReward: Int64 = 0

  ///*
  /// The total of balance of all accounts staked to this account or contract.
  public var stakedToMe: Int64 = 0

  ///*
  /// ID of the account or node to which this account or contract is staking.
  public var stakedID: Proto_StakingInfo.OneOf_StakedID? = nil

  ///*
  /// The account to which this account or contract is staking.
  public var stakedAccountID: Proto_AccountID {
    get {
      if case .stakedAccountID(let v)? = stakedID {return v}
      return Proto_AccountID()
    }
    set {stakedID = .stakedAccountID(newValue)}
  }

  ///*
  /// The ID of the node this account or contract is staked to.
  public var stakedNodeID: Int64 {
    get {
      if case .stakedNodeID(let v)? = stakedID {return v}
      return 0
    }
    set {stakedID = .stakedNodeID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// ID of the account or node to which this account or contract is staking.
  public enum OneOf_StakedID: Equatable {
    ///*
    /// The account to which this account or contract is staking.
    case stakedAccountID(Proto_AccountID)
    ///*
    /// The ID of the node this account or contract is staked to.
    case stakedNodeID(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Proto_StakingInfo.OneOf_StakedID, rhs: Proto_StakingInfo.OneOf_StakedID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stakedAccountID, .stakedAccountID): return {
        guard case .stakedAccountID(let l) = lhs, case .stakedAccountID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stakedNodeID, .stakedNodeID): return {
        guard case .stakedNodeID(let l) = lhs, case .stakedNodeID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _stakePeriodStart: Proto_Timestamp? = nil
}

public struct Proto_VirtualAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The 20-byte EVM address that is derived from the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
  public var address: Data = Data()

  ///*
  /// Flag if this address should now be set or is the default address on the account.
  public var isDefault: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_TokenType: @unchecked Sendable {}
extension Proto_SubType: @unchecked Sendable {}
extension Proto_TokenSupplyType: @unchecked Sendable {}
extension Proto_TokenFreezeStatus: @unchecked Sendable {}
extension Proto_TokenKycStatus: @unchecked Sendable {}
extension Proto_TokenPauseStatus: @unchecked Sendable {}
extension Proto_HederaFunctionality: @unchecked Sendable {}
extension Proto_ShardID: @unchecked Sendable {}
extension Proto_RealmID: @unchecked Sendable {}
extension Proto_AccountID: @unchecked Sendable {}
extension Proto_AccountID.OneOf_Account: @unchecked Sendable {}
extension Proto_FileID: @unchecked Sendable {}
extension Proto_ContractID: @unchecked Sendable {}
extension Proto_ContractID.OneOf_Contract: @unchecked Sendable {}
extension Proto_TransactionID: @unchecked Sendable {}
extension Proto_AccountAmount: @unchecked Sendable {}
extension Proto_TransferList: @unchecked Sendable {}
extension Proto_NftTransfer: @unchecked Sendable {}
extension Proto_TokenTransferList: @unchecked Sendable {}
extension Proto_Fraction: @unchecked Sendable {}
extension Proto_TopicID: @unchecked Sendable {}
extension Proto_TokenID: @unchecked Sendable {}
extension Proto_ScheduleID: @unchecked Sendable {}
extension Proto_Key: @unchecked Sendable {}
extension Proto_Key.OneOf_Key: @unchecked Sendable {}
extension Proto_ThresholdKey: @unchecked Sendable {}
extension Proto_KeyList: @unchecked Sendable {}
extension Proto_Signature: @unchecked Sendable {}
extension Proto_Signature.OneOf_Signature: @unchecked Sendable {}
extension Proto_ThresholdSignature: @unchecked Sendable {}
extension Proto_SignatureList: @unchecked Sendable {}
extension Proto_SignaturePair: @unchecked Sendable {}
extension Proto_SignaturePair.OneOf_Signature: @unchecked Sendable {}
extension Proto_SignatureMap: @unchecked Sendable {}
extension Proto_FeeComponents: @unchecked Sendable {}
extension Proto_TransactionFeeSchedule: @unchecked Sendable {}
extension Proto_FeeData: @unchecked Sendable {}
extension Proto_FeeSchedule: @unchecked Sendable {}
extension Proto_CurrentAndNextFeeSchedule: @unchecked Sendable {}
extension Proto_ServiceEndpoint: @unchecked Sendable {}
extension Proto_NodeAddress: @unchecked Sendable {}
extension Proto_NodeAddressBook: @unchecked Sendable {}
extension Proto_SemanticVersion: @unchecked Sendable {}
extension Proto_Setting: @unchecked Sendable {}
extension Proto_ServicesConfigurationList: @unchecked Sendable {}
extension Proto_TokenRelationship: @unchecked Sendable {}
extension Proto_TokenBalance: @unchecked Sendable {}
extension Proto_TokenBalances: @unchecked Sendable {}
extension Proto_TokenAssociation: @unchecked Sendable {}
extension Proto_StakingInfo: @unchecked Sendable {}
extension Proto_StakingInfo.OneOf_StakedID: @unchecked Sendable {}
extension Proto_VirtualAddress: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_TokenType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FUNGIBLE_COMMON"),
    1: .same(proto: "NON_FUNGIBLE_UNIQUE"),
  ]
}

extension Proto_SubType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "TOKEN_FUNGIBLE_COMMON"),
    2: .same(proto: "TOKEN_NON_FUNGIBLE_UNIQUE"),
    3: .same(proto: "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES"),
    4: .same(proto: "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES"),
    5: .same(proto: "SCHEDULE_CREATE_CONTRACT_CALL"),
  ]
}

extension Proto_TokenSupplyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFINITE"),
    1: .same(proto: "FINITE"),
  ]
}

extension Proto_TokenFreezeStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FreezeNotApplicable"),
    1: .same(proto: "Frozen"),
    2: .same(proto: "Unfrozen"),
  ]
}

extension Proto_TokenKycStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KycNotApplicable"),
    1: .same(proto: "Granted"),
    2: .same(proto: "Revoked"),
  ]
}

extension Proto_TokenPauseStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PauseNotApplicable"),
    1: .same(proto: "Paused"),
    2: .same(proto: "Unpaused"),
  ]
}

extension Proto_HederaFunctionality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "CryptoTransfer"),
    2: .same(proto: "CryptoUpdate"),
    3: .same(proto: "CryptoDelete"),
    4: .same(proto: "CryptoAddLiveHash"),
    5: .same(proto: "CryptoDeleteLiveHash"),
    6: .same(proto: "ContractCall"),
    7: .same(proto: "ContractCreate"),
    8: .same(proto: "ContractUpdate"),
    9: .same(proto: "FileCreate"),
    10: .same(proto: "FileAppend"),
    11: .same(proto: "FileUpdate"),
    12: .same(proto: "FileDelete"),
    13: .same(proto: "CryptoGetAccountBalance"),
    14: .same(proto: "CryptoGetAccountRecords"),
    15: .same(proto: "CryptoGetInfo"),
    16: .same(proto: "ContractCallLocal"),
    17: .same(proto: "ContractGetInfo"),
    18: .same(proto: "ContractGetBytecode"),
    19: .same(proto: "GetBySolidityID"),
    20: .same(proto: "GetByKey"),
    21: .same(proto: "CryptoGetLiveHash"),
    22: .same(proto: "CryptoGetStakers"),
    23: .same(proto: "FileGetContents"),
    24: .same(proto: "FileGetInfo"),
    25: .same(proto: "TransactionGetRecord"),
    26: .same(proto: "ContractGetRecords"),
    27: .same(proto: "CryptoCreate"),
    28: .same(proto: "SystemDelete"),
    29: .same(proto: "SystemUndelete"),
    30: .same(proto: "ContractDelete"),
    31: .same(proto: "Freeze"),
    32: .same(proto: "CreateTransactionRecord"),
    33: .same(proto: "CryptoAccountAutoRenew"),
    34: .same(proto: "ContractAutoRenew"),
    35: .same(proto: "GetVersionInfo"),
    36: .same(proto: "TransactionGetReceipt"),
    50: .same(proto: "ConsensusCreateTopic"),
    51: .same(proto: "ConsensusUpdateTopic"),
    52: .same(proto: "ConsensusDeleteTopic"),
    53: .same(proto: "ConsensusGetTopicInfo"),
    54: .same(proto: "ConsensusSubmitMessage"),
    55: .same(proto: "UncheckedSubmit"),
    56: .same(proto: "TokenCreate"),
    58: .same(proto: "TokenGetInfo"),
    59: .same(proto: "TokenFreezeAccount"),
    60: .same(proto: "TokenUnfreezeAccount"),
    61: .same(proto: "TokenGrantKycToAccount"),
    62: .same(proto: "TokenRevokeKycFromAccount"),
    63: .same(proto: "TokenDelete"),
    64: .same(proto: "TokenUpdate"),
    65: .same(proto: "TokenMint"),
    66: .same(proto: "TokenBurn"),
    67: .same(proto: "TokenAccountWipe"),
    68: .same(proto: "TokenAssociateToAccount"),
    69: .same(proto: "TokenDissociateFromAccount"),
    70: .same(proto: "ScheduleCreate"),
    71: .same(proto: "ScheduleDelete"),
    72: .same(proto: "ScheduleSign"),
    73: .same(proto: "ScheduleGetInfo"),
    74: .same(proto: "TokenGetAccountNftInfos"),
    75: .same(proto: "TokenGetNftInfo"),
    76: .same(proto: "TokenGetNftInfos"),
    77: .same(proto: "TokenFeeScheduleUpdate"),
    78: .same(proto: "NetworkGetExecutionTime"),
    79: .same(proto: "TokenPause"),
    80: .same(proto: "TokenUnpause"),
    81: .same(proto: "CryptoApproveAllowance"),
    82: .same(proto: "CryptoDeleteAllowance"),
    83: .same(proto: "GetAccountDetails"),
    84: .same(proto: "EthereumTransaction"),
    85: .same(proto: "NodeStakeUpdate"),
    86: .same(proto: "UtilPrng"),
  ]
}

extension Proto_ShardID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShardID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ShardID, rhs: Proto_ShardID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RealmID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RealmID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_RealmID, rhs: Proto_RealmID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "accountNum"),
    4: .same(proto: "alias"),
    5: .standard(proto: "evm_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.account != nil {try decoder.handleConflictingOneOf()}
          self.account = .accountNum(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.account != nil {try decoder.handleConflictingOneOf()}
          self.account = .alias(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.account != nil {try decoder.handleConflictingOneOf()}
          self.account = .evmAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    switch self.account {
    case .accountNum?: try {
      guard case .accountNum(let v)? = self.account else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .alias?: try {
      guard case .alias(let v)? = self.account else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .evmAddress?: try {
      guard case .evmAddress(let v)? = self.account else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AccountID, rhs: Proto_AccountID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FileID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "fileNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fileNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.fileNum != 0 {
      try visitor.visitSingularInt64Field(value: self.fileNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FileID, rhs: Proto_FileID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.fileNum != rhs.fileNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ContractID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContractID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "contractNum"),
    4: .standard(proto: "evm_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.contract != nil {try decoder.handleConflictingOneOf()}
          self.contract = .contractNum(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.contract != nil {try decoder.handleConflictingOneOf()}
          self.contract = .evmAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    switch self.contract {
    case .contractNum?: try {
      guard case .contractNum(let v)? = self.contract else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .evmAddress?: try {
      guard case .evmAddress(let v)? = self.contract else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ContractID, rhs: Proto_ContractID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionValidStart"),
    2: .same(proto: "accountID"),
    3: .same(proto: "scheduled"),
    4: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transactionValidStart) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.scheduled) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transactionValidStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.scheduled != false {
      try visitor.visitSingularBoolField(value: self.scheduled, fieldNumber: 3)
    }
    if self.nonce != 0 {
      try visitor.visitSingularInt32Field(value: self.nonce, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionID, rhs: Proto_TransactionID) -> Bool {
    if lhs._transactionValidStart != rhs._transactionValidStart {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs.scheduled != rhs.scheduled {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountAmount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountID"),
    2: .same(proto: "amount"),
    3: .standard(proto: "is_approval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 2: try { try decoder.decodeSingularSInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isApproval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularSInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.isApproval != false {
      try visitor.visitSingularBoolField(value: self.isApproval, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AccountAmount, rhs: Proto_AccountAmount) -> Bool {
    if lhs._accountID != rhs._accountID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.isApproval != rhs.isApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransferList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountAmounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accountAmounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountAmounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountAmounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransferList, rhs: Proto_TransferList) -> Bool {
    if lhs.accountAmounts != rhs.accountAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NftTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NftTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderAccountID"),
    2: .same(proto: "receiverAccountID"),
    3: .same(proto: "serialNumber"),
    4: .standard(proto: "is_approval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._senderAccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._receiverAccountID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.serialNumber) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isApproval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._senderAccountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._receiverAccountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.serialNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.serialNumber, fieldNumber: 3)
    }
    if self.isApproval != false {
      try visitor.visitSingularBoolField(value: self.isApproval, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NftTransfer, rhs: Proto_NftTransfer) -> Bool {
    if lhs._senderAccountID != rhs._senderAccountID {return false}
    if lhs._receiverAccountID != rhs._receiverAccountID {return false}
    if lhs.serialNumber != rhs.serialNumber {return false}
    if lhs.isApproval != rhs.isApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenTransferList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenTransferList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "transfers"),
    3: .same(proto: "nftTransfers"),
    4: .standard(proto: "expected_decimals"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transfers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nftTransfers) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expectedDecimals) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transfers, fieldNumber: 2)
    }
    if !self.nftTransfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nftTransfers, fieldNumber: 3)
    }
    try { if let v = self._expectedDecimals {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenTransferList, rhs: Proto_TokenTransferList) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.transfers != rhs.transfers {return false}
    if lhs.nftTransfers != rhs.nftTransfers {return false}
    if lhs._expectedDecimals != rhs._expectedDecimals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Fraction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Fraction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numerator"),
    2: .same(proto: "denominator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.numerator) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.denominator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numerator != 0 {
      try visitor.visitSingularInt64Field(value: self.numerator, fieldNumber: 1)
    }
    if self.denominator != 0 {
      try visitor.visitSingularInt64Field(value: self.denominator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Fraction, rhs: Proto_Fraction) -> Bool {
    if lhs.numerator != rhs.numerator {return false}
    if lhs.denominator != rhs.denominator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TopicID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "topicNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.topicNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.topicNum != 0 {
      try visitor.visitSingularInt64Field(value: self.topicNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TopicID, rhs: Proto_TopicID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.topicNum != rhs.topicNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "tokenNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.tokenNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.tokenNum != 0 {
      try visitor.visitSingularInt64Field(value: self.tokenNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenID, rhs: Proto_TokenID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.tokenNum != rhs.tokenNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ScheduleID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScheduleID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "scheduleNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.scheduleNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.scheduleNum != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduleNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ScheduleID, rhs: Proto_ScheduleID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.scheduleNum != rhs.scheduleNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdKey"),
    6: .same(proto: "keyList"),
    7: .standard(proto: "ECDSA_secp256k1"),
    8: .standard(proto: "delegatable_contract_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_ContractID?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .contractID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .contractID(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .ed25519(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .rsa3072(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .ecdsa384(v)
        }
      }()
      case 5: try {
        var v: Proto_ThresholdKey?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .thresholdKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .thresholdKey(v)
        }
      }()
      case 6: try {
        var v: Proto_KeyList?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .keyList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .keyList(v)
        }
      }()
      case 7: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .ecdsaSecp256K1(v)
        }
      }()
      case 8: try {
        var v: Proto_ContractID?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .delegatableContractID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .delegatableContractID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.key {
    case .contractID?: try {
      guard case .contractID(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ed25519?: try {
      guard case .ed25519(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .rsa3072?: try {
      guard case .rsa3072(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .ecdsa384?: try {
      guard case .ecdsa384(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .thresholdKey?: try {
      guard case .thresholdKey(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .keyList?: try {
      guard case .keyList(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .ecdsaSecp256K1?: try {
      guard case .ecdsaSecp256K1(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }()
    case .delegatableContractID?: try {
      guard case .delegatableContractID(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Key, rhs: Proto_Key) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.threshold) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.threshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.threshold, fieldNumber: 1)
    }
    try { if let v = self._keys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ThresholdKey, rhs: Proto_ThresholdKey) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs._keys != rhs._keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_KeyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_KeyList, rhs: Proto_KeyList) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Signature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contract"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdSignature"),
    6: .same(proto: "signatureList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .contract(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ed25519(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .rsa3072(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ecdsa384(v)
        }
      }()
      case 5: try {
        var v: Proto_ThresholdSignature?
        var hadOneofValue = false
        if let current = self.signature {
          hadOneofValue = true
          if case .thresholdSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signature = .thresholdSignature(v)
        }
      }()
      case 6: try {
        var v: Proto_SignatureList?
        var hadOneofValue = false
        if let current = self.signature {
          hadOneofValue = true
          if case .signatureList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signature = .signatureList(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.signature {
    case .contract?: try {
      guard case .contract(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .ed25519?: try {
      guard case .ed25519(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .rsa3072?: try {
      guard case .rsa3072(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .ecdsa384?: try {
      guard case .ecdsa384(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .thresholdSignature?: try {
      guard case .thresholdSignature(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .signatureList?: try {
      guard case .signatureList(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Signature, rhs: Proto_Signature) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sigs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sigs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ThresholdSignature, rhs: Proto_ThresholdSignature) -> Bool {
    if lhs._sigs != rhs._sigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignatureList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignatureList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sigs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sigs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignatureList, rhs: Proto_SignatureList) -> Bool {
    if lhs.sigs != rhs.sigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignaturePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignaturePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubKeyPrefix"),
    2: .same(proto: "contract"),
    3: .same(proto: "ed25519"),
    4: .standard(proto: "RSA_3072"),
    5: .standard(proto: "ECDSA_384"),
    6: .standard(proto: "ECDSA_secp256k1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pubKeyPrefix) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .contract(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ed25519(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .rsa3072(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ecdsa384(v)
        }
      }()
      case 6: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ecdsaSecp256K1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pubKeyPrefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKeyPrefix, fieldNumber: 1)
    }
    switch self.signature {
    case .contract?: try {
      guard case .contract(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .ed25519?: try {
      guard case .ed25519(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .rsa3072?: try {
      guard case .rsa3072(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .ecdsa384?: try {
      guard case .ecdsa384(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case .ecdsaSecp256K1?: try {
      guard case .ecdsaSecp256K1(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignaturePair, rhs: Proto_SignaturePair) -> Bool {
    if lhs.pubKeyPrefix != rhs.pubKeyPrefix {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignatureMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignatureMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sigPair"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sigPair) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sigPair.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sigPair, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignatureMap, rhs: Proto_SignatureMap) -> Bool {
    if lhs.sigPair != rhs.sigPair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeComponents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeeComponents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
    3: .same(proto: "constant"),
    4: .same(proto: "bpt"),
    5: .same(proto: "vpt"),
    6: .same(proto: "rbh"),
    7: .same(proto: "sbh"),
    8: .same(proto: "gas"),
    9: .same(proto: "tv"),
    10: .same(proto: "bpr"),
    11: .same(proto: "sbpr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.min) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.max) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.constant) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.bpt) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.vpt) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.rbh) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.sbh) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.gas) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.tv) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.bpr) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.sbpr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularInt64Field(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularInt64Field(value: self.max, fieldNumber: 2)
    }
    if self.constant != 0 {
      try visitor.visitSingularInt64Field(value: self.constant, fieldNumber: 3)
    }
    if self.bpt != 0 {
      try visitor.visitSingularInt64Field(value: self.bpt, fieldNumber: 4)
    }
    if self.vpt != 0 {
      try visitor.visitSingularInt64Field(value: self.vpt, fieldNumber: 5)
    }
    if self.rbh != 0 {
      try visitor.visitSingularInt64Field(value: self.rbh, fieldNumber: 6)
    }
    if self.sbh != 0 {
      try visitor.visitSingularInt64Field(value: self.sbh, fieldNumber: 7)
    }
    if self.gas != 0 {
      try visitor.visitSingularInt64Field(value: self.gas, fieldNumber: 8)
    }
    if self.tv != 0 {
      try visitor.visitSingularInt64Field(value: self.tv, fieldNumber: 9)
    }
    if self.bpr != 0 {
      try visitor.visitSingularInt64Field(value: self.bpr, fieldNumber: 10)
    }
    if self.sbpr != 0 {
      try visitor.visitSingularInt64Field(value: self.sbpr, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FeeComponents, rhs: Proto_FeeComponents) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.constant != rhs.constant {return false}
    if lhs.bpt != rhs.bpt {return false}
    if lhs.vpt != rhs.vpt {return false}
    if lhs.rbh != rhs.rbh {return false}
    if lhs.sbh != rhs.sbh {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.tv != rhs.tv {return false}
    if lhs.bpr != rhs.bpr {return false}
    if lhs.sbpr != rhs.sbpr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionFeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionFeeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hederaFunctionality"),
    2: .same(proto: "feeData"),
    3: .same(proto: "fees"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hederaFunctionality) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feeData) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fees) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.hederaFunctionality != .none {
      try visitor.visitSingularEnumField(value: self.hederaFunctionality, fieldNumber: 1)
    }
    try { if let v = self._feeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.fees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fees, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionFeeSchedule, rhs: Proto_TransactionFeeSchedule) -> Bool {
    if lhs.hederaFunctionality != rhs.hederaFunctionality {return false}
    if lhs._feeData != rhs._feeData {return false}
    if lhs.fees != rhs.fees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeeData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodedata"),
    2: .same(proto: "networkdata"),
    3: .same(proto: "servicedata"),
    4: .same(proto: "subType"),
  ]

  fileprivate class _StorageClass {
    var _nodedata: Proto_FeeComponents? = nil
    var _networkdata: Proto_FeeComponents? = nil
    var _servicedata: Proto_FeeComponents? = nil
    var _subType: Proto_SubType = .default

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nodedata = source._nodedata
      _networkdata = source._networkdata
      _servicedata = source._servicedata
      _subType = source._subType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._nodedata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._networkdata) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._servicedata) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._subType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._nodedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._networkdata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._servicedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._subType != .default {
        try visitor.visitSingularEnumField(value: _storage._subType, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FeeData, rhs: Proto_FeeData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nodedata != rhs_storage._nodedata {return false}
        if _storage._networkdata != rhs_storage._networkdata {return false}
        if _storage._servicedata != rhs_storage._servicedata {return false}
        if _storage._subType != rhs_storage._subType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionFeeSchedule"),
    2: .same(proto: "expiryTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactionFeeSchedule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expiryTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transactionFeeSchedule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactionFeeSchedule, fieldNumber: 1)
    }
    try { if let v = self._expiryTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FeeSchedule, rhs: Proto_FeeSchedule) -> Bool {
    if lhs.transactionFeeSchedule != rhs.transactionFeeSchedule {return false}
    if lhs._expiryTime != rhs._expiryTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CurrentAndNextFeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrentAndNextFeeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currentFeeSchedule"),
    2: .same(proto: "nextFeeSchedule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentFeeSchedule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nextFeeSchedule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentFeeSchedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nextFeeSchedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CurrentAndNextFeeSchedule, rhs: Proto_CurrentAndNextFeeSchedule) -> Bool {
    if lhs._currentFeeSchedule != rhs._currentFeeSchedule {return false}
    if lhs._nextFeeSchedule != rhs._nextFeeSchedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ServiceEndpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceEndpoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ipAddressV4"),
    2: .same(proto: "port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ipAddressV4) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ipAddressV4.isEmpty {
      try visitor.visitSingularBytesField(value: self.ipAddressV4, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ServiceEndpoint, rhs: Proto_ServiceEndpoint) -> Bool {
    if lhs.ipAddressV4 != rhs.ipAddressV4 {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ipAddress"),
    2: .same(proto: "portno"),
    3: .same(proto: "memo"),
    4: .standard(proto: "RSA_PubKey"),
    5: .same(proto: "nodeId"),
    6: .same(proto: "nodeAccountId"),
    7: .same(proto: "nodeCertHash"),
    8: .same(proto: "serviceEndpoint"),
    9: .same(proto: "description"),
    10: .same(proto: "stake"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ipAddress) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.portno) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.memo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rsaPubKey) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.nodeID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._nodeAccountID) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nodeCertHash) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.serviceEndpoint) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.stake) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ipAddress, fieldNumber: 1)
    }
    if self.portno != 0 {
      try visitor.visitSingularInt32Field(value: self.portno, fieldNumber: 2)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularBytesField(value: self.memo, fieldNumber: 3)
    }
    if !self.rsaPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.rsaPubKey, fieldNumber: 4)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.nodeID, fieldNumber: 5)
    }
    try { if let v = self._nodeAccountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nodeCertHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeCertHash, fieldNumber: 7)
    }
    if !self.serviceEndpoint.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceEndpoint, fieldNumber: 8)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 9)
    }
    if self.stake != 0 {
      try visitor.visitSingularInt64Field(value: self.stake, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeAddress, rhs: Proto_NodeAddress) -> Bool {
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.portno != rhs.portno {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.rsaPubKey != rhs.rsaPubKey {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs._nodeAccountID != rhs._nodeAccountID {return false}
    if lhs.nodeCertHash != rhs.nodeCertHash {return false}
    if lhs.serviceEndpoint != rhs.serviceEndpoint {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.stake != rhs.stake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddressBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeAddressBook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodeAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeAddress.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeAddressBook, rhs: Proto_NodeAddressBook) -> Bool {
    if lhs.nodeAddress != rhs.nodeAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SemanticVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SemanticVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "major"),
    2: .same(proto: "minor"),
    3: .same(proto: "patch"),
    4: .same(proto: "pre"),
    5: .same(proto: "build"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.major) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minor) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.patch) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pre) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.build) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.major != 0 {
      try visitor.visitSingularInt32Field(value: self.major, fieldNumber: 1)
    }
    if self.minor != 0 {
      try visitor.visitSingularInt32Field(value: self.minor, fieldNumber: 2)
    }
    if self.patch != 0 {
      try visitor.visitSingularInt32Field(value: self.patch, fieldNumber: 3)
    }
    if !self.pre.isEmpty {
      try visitor.visitSingularStringField(value: self.pre, fieldNumber: 4)
    }
    if !self.build.isEmpty {
      try visitor.visitSingularStringField(value: self.build, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SemanticVersion, rhs: Proto_SemanticVersion) -> Bool {
    if lhs.major != rhs.major {return false}
    if lhs.minor != rhs.minor {return false}
    if lhs.patch != rhs.patch {return false}
    if lhs.pre != rhs.pre {return false}
    if lhs.build != rhs.build {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Setting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Setting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Setting, rhs: Proto_Setting) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ServicesConfigurationList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServicesConfigurationList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nameValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nameValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nameValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nameValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ServicesConfigurationList, rhs: Proto_ServicesConfigurationList) -> Bool {
    if lhs.nameValue != rhs.nameValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenRelationship: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenRelationship"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenId"),
    2: .same(proto: "symbol"),
    3: .same(proto: "balance"),
    4: .same(proto: "kycStatus"),
    5: .same(proto: "freezeStatus"),
    6: .same(proto: "decimals"),
    7: .standard(proto: "automatic_association"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.balance) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.kycStatus) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.freezeStatus) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.automaticAssociation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if self.balance != 0 {
      try visitor.visitSingularUInt64Field(value: self.balance, fieldNumber: 3)
    }
    if self.kycStatus != .kycNotApplicable {
      try visitor.visitSingularEnumField(value: self.kycStatus, fieldNumber: 4)
    }
    if self.freezeStatus != .freezeNotApplicable {
      try visitor.visitSingularEnumField(value: self.freezeStatus, fieldNumber: 5)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 6)
    }
    if self.automaticAssociation != false {
      try visitor.visitSingularBoolField(value: self.automaticAssociation, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenRelationship, rhs: Proto_TokenRelationship) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.kycStatus != rhs.kycStatus {return false}
    if lhs.freezeStatus != rhs.freezeStatus {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.automaticAssociation != rhs.automaticAssociation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenBalance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenId"),
    2: .same(proto: "balance"),
    3: .same(proto: "decimals"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.balance) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.balance != 0 {
      try visitor.visitSingularUInt64Field(value: self.balance, fieldNumber: 2)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenBalance, rhs: Proto_TokenBalance) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenBalances: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenBalances"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenBalances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokenBalances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenBalances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenBalances, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenBalances, rhs: Proto_TokenBalances) -> Bool {
    if lhs.tokenBalances != rhs.tokenBalances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenAssociation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenAssociation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenAssociation, rhs: Proto_TokenAssociation) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_StakingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakingInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "decline_reward"),
    2: .standard(proto: "stake_period_start"),
    3: .standard(proto: "pending_reward"),
    4: .standard(proto: "staked_to_me"),
    5: .standard(proto: "staked_account_id"),
    6: .standard(proto: "staked_node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.declineReward) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stakePeriodStart) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pendingReward) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.stakedToMe) }()
      case 5: try {
        var v: Proto_AccountID?
        var hadOneofValue = false
        if let current = self.stakedID {
          hadOneofValue = true
          if case .stakedAccountID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stakedID = .stakedAccountID(v)
        }
      }()
      case 6: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.stakedID != nil {try decoder.handleConflictingOneOf()}
          self.stakedID = .stakedNodeID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.declineReward != false {
      try visitor.visitSingularBoolField(value: self.declineReward, fieldNumber: 1)
    }
    try { if let v = self._stakePeriodStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pendingReward != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingReward, fieldNumber: 3)
    }
    if self.stakedToMe != 0 {
      try visitor.visitSingularInt64Field(value: self.stakedToMe, fieldNumber: 4)
    }
    switch self.stakedID {
    case .stakedAccountID?: try {
      guard case .stakedAccountID(let v)? = self.stakedID else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .stakedNodeID?: try {
      guard case .stakedNodeID(let v)? = self.stakedID else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_StakingInfo, rhs: Proto_StakingInfo) -> Bool {
    if lhs.declineReward != rhs.declineReward {return false}
    if lhs._stakePeriodStart != rhs._stakePeriodStart {return false}
    if lhs.pendingReward != rhs.pendingReward {return false}
    if lhs.stakedToMe != rhs.stakedToMe {return false}
    if lhs.stakedID != rhs.stakedID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_VirtualAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VirtualAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "is_default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isDefault) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_VirtualAddress, rhs: Proto_VirtualAddress) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
